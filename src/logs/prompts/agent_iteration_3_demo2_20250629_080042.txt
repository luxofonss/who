Project: demo2
Timestamp: 2025-06-29T08:00:42.417967
Type: agent_iteration_3
================================================================================

You are an expert software architect analyzing the REST endpoint: /api/v1/pub/pronunciations/samples
            ANALYSIS STRATEGY:
            1. Review the current context for the endpoint implementation
            2. Get all classes, services, repositories, DTOs, methods and check if they are fully implemented
            3. If you see references to any classes, services, DTOs, or methods that are not fully shown, request more context using the tool
            4. When there are no classes, services, DTOs, or methods that are not fully shown, you have sufficient implementation details, provide your final analysis as JSON
            5. Do not assume that you have enough context, always check the code and use get_project_code_context if any part of the code is not fully implemented.

            WHEN TO USE get_project_code_context TOOL:
            - When you see class/interface names without their implementation
            - When service methods are referenced but not shown
            - When DTO/model classes are mentioned but structure is unclear
            - When exception handling classes are referenced
            - When you need to understand dependencies or business logic

            To use the tool, respond with: "I need to get context for [exact_class_or_method_name]"
            Examples:
            - "I need to get context for UserService"
            - "I need to get context for ValidationException"
            - "I need to get context for OrderDto"

            CURRENT CONTEXT:
            # Summary: 
@GetMapping("/attempts")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getQuizAttempts(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizAttempts(currentUser.getId().toString()));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

@GetMapping("/my")
    BaseResponse<List<Quiz>> getMyQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizzes(currentUser.getId()));

'PronunciationAccuracyResponseDto':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PronunciationAccuracyResponseDto {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

'quizService':
# Summary: 

@Override
    public BaseCreateUpdateResponse createQuiz(CreateQuizDto request, UUID authorId) {
        Quiz q = quizMapper.createQuizDtoToQuiz(request);
        q.setAuthorId(authorId);
        quizRepository.save(q);
        return new BaseCreateUpdateResponse(q.getId().toString());
    }

# Summary: 

@Override
    @Transactional(rollbackFor = Exception.class)
    public BaseCreateUpdateResponse updateQuiz(CreateQuizDto request) {
        if (request.getId() == null) {
            throw new IllegalArgumentException("Quiz ID must be provided for update operation.");
        }
        UUID quizId = UUID.fromString(request.getId());
        Quiz existingQuiz = quizRepository.findById(request.getId())
                .orElseThrow(() -> new EntityNotFoundException("Quiz with ID " + request.getId() + " not found."));

        quizMapper.updateQuizFromDto(request, existingQuiz);
        existingQuiz.setUpdatedAt(LocalDateTime.now());
        if (request.getIsPublic()) {
            existingQuiz.setStatus(QuizStatus.PUBLIC);
        } else {
            existingQuiz.setStatus(QuizStatus.DRAFT);
        }

        List<Question> existingQuestions = questionRepository.findByQuizId(request.getId());
        Map<UUID, Question> existingQuestionMap = existingQuestions.stream()
                .collect(Collectors.toMap(Question::getId, q -> q));

        List<Question> questionsToSaveOrUpdate = new ArrayList<>();
        Set<UUID> questionIdsInDto = request.getQuestions().stream()
                .filter(qDto -> qDto.getId() != null)
                .map(qDto -> UUID.fromString(qDto.getId()))
                .collect(Collectors.toSet());

        for (QuestionDto qDto : request.getQuestions()) {
            if (qDto.getId() == null) {
                Question newQuestion = questionMapper.questionDtoToQuestion(qDto);
                newQuestion.setQuizId(quizId);
                newQuestion.setCreatedAt(LocalDateTime.now());
                newQuestion.setUpdatedAt(LocalDateTime.now());
                if (!CollectionUtils.isEmpty(newQuestion.getOptions())) {
                    for (QuestionOption option : newQuestion.getOptions()) {
                        option.setId(UUID.randomUUID());
                    }
                }
                questionsToSaveOrUpdate.add(newQuestion);
            } else {
                UUID qId = UUID.fromString(qDto.getId());
                Question questionToUpdate = existingQuestionMap.get(qId);
                if (questionToUpdate != null) {
                    questionMapper.updateQuestionFromDto(qDto, questionToUpdate);
                    questionToUpdate.setUpdatedAt(LocalDateTime.now());
                    // Ensure options are updated correctly
                    if (!CollectionUtils.isEmpty(questionToUpdate.getOptions())) {
                        for (QuestionOption option : questionToUpdate.getOptions()) {
                            if (option.getId() == null) {
                                option.setId(UUID.randomUUID());
                            }
                        }
                    }
                    questionsToSaveOrUpdate.add(questionToUpdate);
                }
            }
        }

        List<Question> questionsToDelete = existingQuestions.stream()
                .filter(eq -> !questionIdsInDto.contains(eq.getId()))
                .collect(Collectors.toList());

        if (!questionsToDelete.isEmpty()) {
            questionRepository.deleteAll(questionsToDelete);
        }
        if (!questionsToSaveOrUpdate.isEmpty()) {
            questionRepository.saveAll(questionsToSaveOrUpdate);
        }

        existingQuiz.setQuestionCount(questionRepository.countByQuizId(quizId.toString()));

        quizRepository.save(existingQuiz);
        return new BaseCreateUpdateResponse(existingQuiz.getId().toString());
    }

# Summary: 

@Override
    public List<Quiz> getAllPublicQuizzes() {
        List<Quiz> quizzes = quizRepository.findAllPublic();
        getQuizAuthor(quizzes);
        return quizzes;
    }

# Summary: 

@Override
    public List<Quiz> getMyQuizzes(UUID id) {
        List<Quiz> quizzes = quizRepository.findByUserId(id);
        getQuizAuthor(quizzes);
        return quizzes;
    }

# Summary: 

@Override
    public Quiz getById(String id) {
        Quiz quiz = quizRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));
        Set<Question> questions = new HashSet<>(questionRepository.findByQuizId(id));
        quiz.setQuestions(questions);
        getQuizAuthor(Collections.singletonList(quiz));
        return quiz;
    }

# Summary: 

@Override
    public void deleteQuiz(String id) {
        Quiz quiz = quizRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));
        quiz.setDeletedAt(LocalDateTime.now());
        quizRepository.save(quiz);
    }

# Summary: 

@Override
    @Transactional
    public BaseCreateUpdateResponse startQuiz(String quizId, UUID userId) {
        quizRepository.findById(quizId)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));

        QuizAttempt quizAttempt = new QuizAttempt();
        quizAttempt.setQuizId(UUID.fromString(quizId));
        quizAttempt.setUserId(userId);
        quizAttempt.setScore(BigDecimal.ZERO);
        quizAttempt.setCorrectAnswers(0);
        quizAttempt.setTimeSpent(0L);
        quizAttempt.setCompletedAt(null);
        quizAttempt.setPassed(false);

        QuizAttempt savedAttempt = quizAttemptRepository.save(quizAttempt);
        return new BaseCreateUpdateResponse(savedAttempt.getId().toString());
    }

# Summary: 

@Override
    @Transactional
    public BaseCreateUpdateResponse submitQuizQuestion(String attemptId, SubmitAnswerRequest request, UUID id) {
        UUID questionId = UUID.fromString(request.getQuestionId());

        QuizAttempt quizAttempt = quizAttemptRepository.findById(attemptId)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND));

        // Ensure the quiz attempt is not already completed
        if (quizAttempt.getCompletedAt() != null) {
            throw new BusinessException(ErrorConstant.QUIZ_ATTEMPT_SUBMITTED);
        }

        Quiz quiz = quizRepository.findById(quizAttempt.getQuizId().toString()).orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));

        // calculate if time is exceeded by field created_at and quiz.getTimeLimit()
        if (quiz.getTimeLimit() != null && quizAttempt.getCreatedAt() != null) {
            LocalDateTime start = quizAttempt.getCreatedAt();
            LocalDateTime end = LocalDateTime.now();
            long timeSpent = Duration.between(start, end).toMinutes();
            if (timeSpent > quiz.getTimeLimit()) {
                quizAttempt.setTimeSpent(timeSpent);
                quizAttempt.setCompletedAt(quizAttempt.getCreatedAt().plusMinutes(timeSpent));
                quizAttemptRepository.save(quizAttempt);
                throw new BusinessException(ErrorConstant.QUIZ_TIME_LIMIT_EXCEEDED);
            }
        }

        Question question = questionRepository.findById(request.getQuestionId())
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUESTION_NOT_FOUND));

        if (!Objects.equals(question.getQuizId(), quizAttempt.getQuizId())) {
            throw new BusinessException(ErrorConstant.QUESTION_DOES_NOT_BELONG_TO_QUIZ);
        }

        // Prepare QuizAnswer entity
        QuizAnswer quizAnswer = new QuizAnswer();
        quizAnswer.setQuestionId(questionId);

        if (QuestionType.MULTIPLE_CHOICE.name().equals(question.getType()) && !CollectionUtils.isEmpty(question.getOptions())) {
            List<QuestionOption> options = question.getOptions().stream()
                    .filter(option -> option.getId() != null && request.getSelectedOptions().contains(option.getId().toString()))
                    .collect(Collectors.toList());
            quizAnswer.setSelectedAnswers(options);
        }
        quizAnswer.setFillInBlanksAnswers(request.getFillInBlanksAnswers());
        quizAnswer.setAnswerText(request.getAnswerText());
        quizAnswer.setTimeTaken(request.getTimeTaken());
        quizAnswer.setAudioUrl(request.getAudioUrl());

        boolean isCorrect = false;
        Integer scoreAchieved = 0;

        // Determine if the answer is correct based on question type
        switch (question.getType().toLowerCase()) {
            case "multiple_choice":
                List<String> userSelectedValues = request.getSelectedOptions() != null ?
                        request.getSelectedOptions().stream()
                                .filter(Objects::nonNull)
                                .collect(Collectors.toList()) : new ArrayList<>();

                List<String> correctOptionValues = question.getCorrectAnswer() != null ?
                        question.getOptions().stream().filter(QuestionOption::getIsCorrect).map(i -> i.getId().toString()).sorted().toList() : new ArrayList<>();
                userSelectedValues.sort(String::compareTo);

                isCorrect = userSelectedValues.equals(correctOptionValues);
                break;
            case "true_false":
                isCorrect = (request.getUserAnswerTrueFalse() != null &&
                        request.getUserAnswerTrueFalse().equals(question.getTrueFalseAnswer()));
                break;
            case "fill_in_the_blank":
                List<String> userFillInBlanks = request.getFillInBlanksAnswers() != null ?
                        request.getFillInBlanksAnswers().stream()
                                .filter(Objects::nonNull)
                                .map(i -> i.toLowerCase().trim())
                                .collect(Collectors.toList()) : new ArrayList<>();

                List<String> correctBlanks = question.getCorrectBlanks() != null ?
                        question.getCorrectBlanks().stream()
                                .filter(Objects::nonNull)
                                .map(i -> i.toLowerCase().trim())
                                .collect(Collectors.toList()) : new ArrayList<>();

                Collections.sort(userFillInBlanks);
                Collections.sort(correctBlanks);

                isCorrect = userFillInBlanks.equals(correctBlanks);
                break;
            case "short_answer":
                isCorrect = (request.getAnswerText() != null &&
                        question.getCorrectAnswer() != null &&
                        !question.getCorrectAnswer().isEmpty() &&
                        question.getCorrectAnswer().getFirst().equalsIgnoreCase(request.getAnswerText().trim()));
                break;
            case "pronunciation":
                if (request.getAudioUrl() == null || request.getAudioUrl().isEmpty()) {
                    break;
                }
                File audioFile = resourceService.downloadResourceFromUrl(request.getAudioUrl());
                if (audioFile == null || !audioFile.exists()) {
                    break;
                }
                String base64File = "data:audio/ogg;;base64," + FileUtils.convertToBase64(audioFile);
                if (base64File == null) {
                    break;
                }
                try {
                    PronunciationAccuracyResponseDto pronunAccuracy = pronunciationService.getAccuracy(
                            PronunciationAccuracyRequestDto.builder()
                                    .base64Audio(base64File)
                                    .text(question.getPronunciationText())
                                    .build()
                    );
                    isCorrect = pronunAccuracy.getPronunciationAccuracy() >= question.getAcceptRate();
                    quizAnswer.setAnswerText(JsonUtils.toJsonString(pronunAccuracy));
                } catch (Exception e) {
                    log.error("Error while checking pronunciation accuracy: {}", e.getMessage());
                }
                break;

            default:
                System.err.println("Unknown question type: " + question.getType());
        }

        if (isCorrect) {
            scoreAchieved = question.getPoints() != null ? question.getPoints() : 0;
        }

        quizAnswer.setCorrect(isCorrect);
        quizAnswer.setScoreAchieved(scoreAchieved);

        List<QuizAnswer> currentAnswers = quizAnswerRepository.findByQuizAttemptId(attemptId);

        for (int i = 0; i < currentAnswers.size(); i++) {
            if (currentAnswers.get(i).getQuestionId().equals(questionId)) {
                QuizAnswer oldAnswer = currentAnswers.get(i);
                quizAttempt.setScore(quizAttempt.getScore().subtract(BigDecimal.valueOf(oldAnswer.getScoreAchieved())));
                if (oldAnswer.isCorrect()) {
                    quizAttempt.setCorrectAnswers(quizAttempt.getCorrectAnswers() - 1);
                }
                quizAnswerRepository.delete(oldAnswer);
                break;
            }
        }

        quizAnswer.setQuizAttemptId(UUID.fromString(attemptId));
        // check if question submitted before
        quizAnswerRepository.save(quizAnswer);

        quizAttempt.setScore(quizAttempt.getScore().add(BigDecimal.valueOf(scoreAchieved)));
        if (isCorrect) {
            quizAttempt.setCorrectAnswers(quizAttempt.getCorrectAnswers() + 1);
        }

        // update total score
        quizAttemptRepository.save(quizAttempt);

        return new BaseCreateUpdateResponse(quizAnswer.getId().toString());
    }

# Summary: 

@Override
    public List<Quiz> getMyQuizAttempts(String userId) {
        List<QuizAttempt> attempts = quizAttemptRepository.findByUserId(UUID.fromString(userId));
        if (CollectionUtils.isEmpty(attempts)) {
            return Collections.emptyList();
        }

        Set<String> quizId = attempts.stream()
                .map(QuizAttempt::getQuizId)
                .map(UUID::toString)
                .collect(Collectors.toSet());

        List<Quiz> quizzes = quizRepository.findByIdIn(quizId);
        if (CollectionUtils.isEmpty(quizzes)) {
            return Collections.emptyList();
        }

        getQuizAuthor(quizzes);

        Map<UUID, List<QuizAttempt>> attemptMap = attempts.stream()
                .collect(Collectors.groupingBy(QuizAttempt::getQuizId));
        for (Quiz quiz : quizzes) {
            quiz.setQuizAttempts(new HashSet<>(attemptMap.get(quiz.getId())));
        }

        return quizzes;
    }

# Summary: 

@Override
    public QuizAttempt getAttempt(String attemptId, UUID userId) {
        // TODO: check permission
        QuizAttempt attempt = quizAttemptRepository.findById(attemptId).orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND));
        Quiz quiz = this.getById(attempt.getQuizId().toString());
        getQuizAuthor(Collections.singletonList(quiz));
        attempt.setQuiz(quiz);
        List<QuizAnswer> answers = quizAnswerRepository.findByQuizAttemptId(attemptId);
        attempt.setAnswers(answers);

        return attempt;
    }

# Summary: 

@Override
    public void submitQuizComplete(String attemptId, UUID id) {
        QuizAttempt attempt = quizAttemptRepository.findById(attemptId).orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND));
        if (!id.equals(attempt.getUserId())) {
            throw new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_BELONG_TO_USER);
        }

        if (attempt.getCompletedAt() != null) {
            throw new BusinessException(ErrorConstant.QUIZ_ATTEMPT_SUBMITTED);
        }
        attempt.setCompletedAt(LocalDateTime.now());
        quizAttemptRepository.save(attempt);
        log.info("saved quiz attempt with id: {}", attemptId);
    }

# Summary: 

@Override
    public Quiz getQuizStatsById(String id) {
        Quiz quiz = quizRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));
        getQuizAuthor(Collections.singletonList(quiz));
        List<Question> questions = questionRepository.findByQuizId(id);
        quiz.setQuestions(new HashSet<>(questions));
        List<QuizAttempt> attempts = quizAttemptRepository.findByQuizId(quiz.getId().toString());

        attempts.forEach(attempt -> {
            userRepository.getUserById(attempt.getUserId().toString()).ifPresent(attempt::setUser);
        });

        quiz.setQuizAttempts(new HashSet<>(attempts));
        List<User> savedUsers = savedQuizRepository.findAllByQuizId(id)
                .stream()
                .map(savedQuiz -> userRepository.getUserById(savedQuiz.getUserId().toString()).orElse(null))
                .filter(Objects::nonNull)
                .toList();
        quiz.setSavedByUsers(new HashSet<>(savedUsers));

        return quiz;
    }

# Summary: 

@Override
    public void saveQuiz(String quizId, UUID userId) {
        savedQuizRepository.saveQuiz(quizId, userId.toString());
    }

# Summary: 

@Override
    public List<Quiz> getSavedQuizzes(UUID userId) {
        List<UserSavedQuiz> savedQuizzes = savedQuizRepository.findAllByUserId(userId.toString());
        if (CollectionUtils.isEmpty(savedQuizzes)) {
            return Collections.emptyList();
        }

        Set<String> quizIds = savedQuizzes.stream()
                .map(UserSavedQuiz::getQuizId)
                .map(UUID::toString)
                .collect(Collectors.toSet());
        if (CollectionUtils.isEmpty(quizIds)) {
            return Collections.emptyList();
        }

        List<Quiz> quizzes = quizRepository.findByIdIn(quizIds);
        if (CollectionUtils.isEmpty(quizzes)) {
            return Collections.emptyList();
        }

        getQuizAuthor(quizzes);

        return quizzes;
    }

# Summary: 

@Override
    public void unsaveQuiz(String quizId, UUID userId) {
        UserSavedQuiz savedQuiz = savedQuizRepository.findAllByQuizId(quizId)
                .stream()
                .filter(q -> q.getUserId().equals(userId))
                .findFirst()
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_SAVED));

        savedQuiz.setSavedAt(LocalDateTime.now());
        savedQuiz.setDeletedAt(null);
        savedQuizRepository.update(savedQuiz);
    }

# Summary: 

@Override
    public List<UserSavedQuiz> getUserSavedQuiz(String quizId, UUID userId) {
        List<UserSavedQuiz> savedQuizzes = savedQuizRepository.findAllByUserId(userId.toString());
        savedQuizzes.forEach(savedQuiz -> {
            userRepository.getUserById(savedQuiz.getUserId().toString()).ifPresent(savedQuiz::setUser);
        });
        return savedQuizzes;
    }

# Summary: 

private void getQuizAuthor(List<Quiz> quizzes) {
        quizzes.forEach(q -> {
            if (q.getAuthorId() != null) {
                q.setAuthor(userRepository.getUserById(q.getAuthorId().toString()).orElse(null));
            }
        });
    }

'baseService':
# Summary: 

public String getMessage(BusinessError error) {
        return ObjectUtils.isEmpty(error.getMessage()) ? getMessage(error.getCode()) : error.getMessage();
    }

# Summary: 

public String getRequestStringValue(String key) {
        return getRequestValue(key, String.class);
    }

# Summary: 

public Object getRequestBody() {
        return getRequestValue(RequestKeyConstant.REQUEST_BODY);
    }

# Summary: 

public <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        return BaseResponse.ofGetListSucceeded(data, requestList);
    }

# Summary: 

public <T> BaseResponse<T> ofFailed(int errorCode, T data) {
        return BaseResponse.ofFailed(getRequestId(), getBusinessError(errorCode), data);
    }

# Summary: 

public BusinessError getBusinessError(int errorCode) {
        return BusinessError.builder()
                .code(errorCode)
                .message(getMessage(errorCode))
                .build();
    }

# Summary: 

public HttpHeaders getHeaders() {
        HttpHeaders headers = new HttpHeaders();
        Enumeration<String> headerNames = httpServletRequest.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = httpServletRequest.getHeader(headerName);
            headers.add(headerName, headerValue);
        }
        return headers;
    }

# Summary: 

public int getErrorCode(String errorCode, int errorCodeDefault) {
        try {
            return Integer.parseInt(errorCode);
        } catch (NumberFormatException e) {
            return errorCodeDefault;
        }
    }

'UserPrincipal':
# Summary: 

@Override
    public Collection<? extends GrantedAuthority> getAuthorities(){
        return roles.stream()
                .map(SimpleGrantedAuthority::new)
                .toList();
    }

# Summary: 

public static UserPrincipal from(User user) {
        return UserPrincipal.builder()
                .id(UUID.fromString(user.getId().toString()))
                .username(user.getUsername())
                .email(user.getEmail())
                .password(user.getCredentials().getPasswordHash())
                .roles(List.of(user.getRole().toString()))
                .build();
    }

# Summary: 

@Override
    public String getPassword() {
        return password;
    }

# Summary: 

@Override
    public String getUsername() {
        return username;
    }

# Summary: 

@Override
    public boolean isAccountNonExpired() {
        return true;
    }

# Summary: 

@Override
    public boolean isAccountNonLocked() {
        return true;
    }

# Summary: 

@Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

# Summary: 

@Override
    public boolean isEnabled() {
        return true;
    }

'BaseResponse':
# Summary: 

public static void verifyMetaResponse(BaseResponse<?> baseResponse, HttpStatus httpStatus, int status) {
        if (Objects.isNull(baseResponse) || Objects.isNull(baseResponse.meta)) {
            return;
        }

        Meta meta = baseResponse.meta;
        if (status != meta.getCode()) {
            throw new BusinessException(meta.getCode(), meta.getMessage(), httpStatus);
        }
    }

# Summary: 

public static <T> BaseResponse<T> ofFailed(String requestId, BusinessException exception, T data) {
        BaseResponse<T> response = ofFailed(exception, data);
        response.meta.setRequestId(requestId);
        response.data = data;
        return response;
    }

# Summary: 

public static <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        BaseResponse<T> response = ofSucceeded(data);
        response.meta.setRequestId(requestList.getRequestId());
        response.meta.setPageSize(requestList.getPageSize());
        response.meta.setPageIndex(requestList.getPageIndex());
        response.meta.setTotalItems(requestList.getTotalItems());
        response.data = data;
        return response;
    }

'PronunciationAccuracyResponseDto':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PronunciationAccuracyResponseDto {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

'quizService':
# Summary: 

@Override
    public BaseCreateUpdateResponse createQuiz(CreateQuizDto request, UUID authorId) {
        Quiz q = quizMapper.createQuizDtoToQuiz(request);
        q.setAuthorId(authorId);
        quizRepository.save(q);
        return new BaseCreateUpdateResponse(q.getId().toString());
    }

# Summary: 

@Override
    @Transactional(rollbackFor = Exception.class)
    public BaseCreateUpdateResponse updateQuiz(CreateQuizDto request) {
        if (request.getId() == null) {
            throw new IllegalArgumentException("Quiz ID must be provided for update operation.");
        }
        UUID quizId = UUID.fromString(request.getId());
        Quiz existingQuiz = quizRepository.findById(request.getId())
                .orElseThrow(() -> new EntityNotFoundException("Quiz with ID " + request.getId() + " not found."));

        quizMapper.updateQuizFromDto(request, existingQuiz);
        existingQuiz.setUpdatedAt(LocalDateTime.now());
        if (request.getIsPublic()) {
            existingQuiz.setStatus(QuizStatus.PUBLIC);
        } else {
            existingQuiz.setStatus(QuizStatus.DRAFT);
        }

        List<Question> existingQuestions = questionRepository.findByQuizId(request.getId());
        Map<UUID, Question> existingQuestionMap = existingQuestions.stream()
                .collect(Collectors.toMap(Question::getId, q -> q));

        List<Question> questionsToSaveOrUpdate = new ArrayList<>();
        Set<UUID> questionIdsInDto = request.getQuestions().stream()
                .filter(qDto -> qDto.getId() != null)
                .map(qDto -> UUID.fromString(qDto.getId()))
                .collect(Collectors.toSet());

        for (QuestionDto qDto : request.getQuestions()) {
            if (qDto.getId() == null) {
                Question newQuestion = questionMapper.questionDtoToQuestion(qDto);
                newQuestion.setQuizId(quizId);
                newQuestion.setCreatedAt(LocalDateTime.now());
                newQuestion.setUpdatedAt(LocalDateTime.now());
                if (!CollectionUtils.isEmpty(newQuestion.getOptions())) {
                    for (QuestionOption option : newQuestion.getOptions()) {
                        option.setId(UUID.randomUUID());
                    }
                }
                questionsToSaveOrUpdate.add(newQuestion);
            } else {
                UUID qId = UUID.fromString(qDto.getId());
                Question questionToUpdate = existingQuestionMap.get(qId);
                if (questionToUpdate != null) {
                    questionMapper.updateQuestionFromDto(qDto, questionToUpdate);
                    questionToUpdate.setUpdatedAt(LocalDateTime.now());
                    // Ensure options are updated correctly
                    if (!CollectionUtils.isEmpty(questionToUpdate.getOptions())) {
                        for (QuestionOption option : questionToUpdate.getOptions()) {
                            if (option.getId() == null) {
                                option.setId(UUID.randomUUID());
                            }
                        }
                    }
                    questionsToSaveOrUpdate.add(questionToUpdate);
                }
            }
        }

        List<Question> questionsToDelete = existingQuestions.stream()
                .filter(eq -> !questionIdsInDto.contains(eq.getId()))
                .collect(Collectors.toList());

        if (!questionsToDelete.isEmpty()) {
            questionRepository.deleteAll(questionsToDelete);
        }
        if (!questionsToSaveOrUpdate.isEmpty()) {
            questionRepository.saveAll(questionsToSaveOrUpdate);
        }

        existingQuiz.setQuestionCount(questionRepository.countByQuizId(quizId.toString()));

        quizRepository.save(existingQuiz);
        return new BaseCreateUpdateResponse(existingQuiz.getId().toString());
    }

# Summary: 

@Override
    public List<Quiz> getAllPublicQuizzes() {
        List<Quiz> quizzes = quizRepository.findAllPublic();
        getQuizAuthor(quizzes);
        return quizzes;
    }

# Summary: 

@Override
    public List<Quiz> getMyQuizzes(UUID id) {
        List<Quiz> quizzes = quizRepository.findByUserId(id);
        getQuizAuthor(quizzes);
        return quizzes;
    }

# Summary: 

@Override
    public Quiz getById(String id) {
        Quiz quiz = quizRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));
        Set<Question> questions = new HashSet<>(questionRepository.findByQuizId(id));
        quiz.setQuestions(questions);
        getQuizAuthor(Collections.singletonList(quiz));
        return quiz;
    }

# Summary: 

@Override
    public void deleteQuiz(String id) {
        Quiz quiz = quizRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));
        quiz.setDeletedAt(LocalDateTime.now());
        quizRepository.save(quiz);
    }

# Summary: 

@Override
    @Transactional
    public BaseCreateUpdateResponse startQuiz(String quizId, UUID userId) {
        quizRepository.findById(quizId)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));

        QuizAttempt quizAttempt = new QuizAttempt();
        quizAttempt.setQuizId(UUID.fromString(quizId));
        quizAttempt.setUserId(userId);
        quizAttempt.setScore(BigDecimal.ZERO);
        quizAttempt.setCorrectAnswers(0);
        quizAttempt.setTimeSpent(0L);
        quizAttempt.setCompletedAt(null);
        quizAttempt.setPassed(false);

        QuizAttempt savedAttempt = quizAttemptRepository.save(quizAttempt);
        return new BaseCreateUpdateResponse(savedAttempt.getId().toString());
    }

# Summary: 

@Override
    @Transactional
    public BaseCreateUpdateResponse submitQuizQuestion(String attemptId, SubmitAnswerRequest request, UUID id) {
        UUID questionId = UUID.fromString(request.getQuestionId());

        QuizAttempt quizAttempt = quizAttemptRepository.findById(attemptId)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND));

        // Ensure the quiz attempt is not already completed
        if (quizAttempt.getCompletedAt() != null) {
            throw new BusinessException(ErrorConstant.QUIZ_ATTEMPT_SUBMITTED);
        }

        Quiz quiz = quizRepository.findById(quizAttempt.getQuizId().toString()).orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));

        // calculate if time is exceeded by field created_at and quiz.getTimeLimit()
        if (quiz.getTimeLimit() != null && quizAttempt.getCreatedAt() != null) {
            LocalDateTime start = quizAttempt.getCreatedAt();
            LocalDateTime end = LocalDateTime.now();
            long timeSpent = Duration.between(start, end).toMinutes();
            if (timeSpent > quiz.getTimeLimit()) {
                quizAttempt.setTimeSpent(timeSpent);
                quizAttempt.setCompletedAt(quizAttempt.getCreatedAt().plusMinutes(timeSpent));
                quizAttemptRepository.save(quizAttempt);
                throw new BusinessException(ErrorConstant.QUIZ_TIME_LIMIT_EXCEEDED);
            }
        }

        Question question = questionRepository.findById(request.getQuestionId())
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUESTION_NOT_FOUND));

        if (!Objects.equals(question.getQuizId(), quizAttempt.getQuizId())) {
            throw new BusinessException(ErrorConstant.QUESTION_DOES_NOT_BELONG_TO_QUIZ);
        }

        // Prepare QuizAnswer entity
        QuizAnswer quizAnswer = new QuizAnswer();
        quizAnswer.setQuestionId(questionId);

        if (QuestionType.MULTIPLE_CHOICE.name().equals(question.getType()) && !CollectionUtils.isEmpty(question.getOptions())) {
            List<QuestionOption> options = question.getOptions().stream()
                    .filter(option -> option.getId() != null && request.getSelectedOptions().contains(option.getId().toString()))
                    .collect(Collectors.toList());
            quizAnswer.setSelectedAnswers(options);
        }
        quizAnswer.setFillInBlanksAnswers(request.getFillInBlanksAnswers());
        quizAnswer.setAnswerText(request.getAnswerText());
        quizAnswer.setTimeTaken(request.getTimeTaken());
        quizAnswer.setAudioUrl(request.getAudioUrl());

        boolean isCorrect = false;
        Integer scoreAchieved = 0;

        // Determine if the answer is correct based on question type
        switch (question.getType().toLowerCase()) {
            case "multiple_choice":
                List<String> userSelectedValues = request.getSelectedOptions() != null ?
                        request.getSelectedOptions().stream()
                                .filter(Objects::nonNull)
                                .collect(Collectors.toList()) : new ArrayList<>();

                List<String> correctOptionValues = question.getCorrectAnswer() != null ?
                        question.getOptions().stream().filter(QuestionOption::getIsCorrect).map(i -> i.getId().toString()).sorted().toList() : new ArrayList<>();
                userSelectedValues.sort(String::compareTo);

                isCorrect = userSelectedValues.equals(correctOptionValues);
                break;
            case "true_false":
                isCorrect = (request.getUserAnswerTrueFalse() != null &&
                        request.getUserAnswerTrueFalse().equals(question.getTrueFalseAnswer()));
                break;
            case "fill_in_the_blank":
                List<String> userFillInBlanks = request.getFillInBlanksAnswers() != null ?
                        request.getFillInBlanksAnswers().stream()
                                .filter(Objects::nonNull)
                                .map(i -> i.toLowerCase().trim())
                                .collect(Collectors.toList()) : new ArrayList<>();

                List<String> correctBlanks = question.getCorrectBlanks() != null ?
                        question.getCorrectBlanks().stream()
                                .filter(Objects::nonNull)
                                .map(i -> i.toLowerCase().trim())
                                .collect(Collectors.toList()) : new ArrayList<>();

                Collections.sort(userFillInBlanks);
                Collections.sort(correctBlanks);

                isCorrect = userFillInBlanks.equals(correctBlanks);
                break;
            case "short_answer":
                isCorrect = (request.getAnswerText() != null &&
                        question.getCorrectAnswer() != null &&
                        !question.getCorrectAnswer().isEmpty() &&
                        question.getCorrectAnswer().getFirst().equalsIgnoreCase(request.getAnswerText().trim()));
                break;
            case "pronunciation":
                if (request.getAudioUrl() == null || request.getAudioUrl().isEmpty()) {
                    break;
                }
                File audioFile = resourceService.downloadResourceFromUrl(request.getAudioUrl());
                if (audioFile == null || !audioFile.exists()) {
                    break;
                }
                String base64File = "data:audio/ogg;;base64," + FileUtils.convertToBase64(audioFile);
                if (base64File == null) {
                    break;
                }
                try {
                    PronunciationAccuracyResponseDto pronunAccuracy = pronunciationService.getAccuracy(
                            PronunciationAccuracyRequestDto.builder()
                                    .base64Audio(base64File)
                                    .text(question.getPronunciationText())
                                    .build()
                    );
                    isCorrect = pronunAccuracy.getPronunciationAccuracy() >= question.getAcceptRate();
                    quizAnswer.setAnswerText(JsonUtils.toJsonString(pronunAccuracy));
                } catch (Exception e) {
                    log.error("Error while checking pronunciation accuracy: {}", e.getMessage());
                }
                break;

            default:
                System.err.println("Unknown question type: " + question.getType());
        }

        if (isCorrect) {
            scoreAchieved = question.getPoints() != null ? question.getPoints() : 0;
        }

        quizAnswer.setCorrect(isCorrect);
        quizAnswer.setScoreAchieved(scoreAchieved);

        List<QuizAnswer> currentAnswers = quizAnswerRepository.findByQuizAttemptId(attemptId);

        for (int i = 0; i < currentAnswers.size(); i++) {
            if (currentAnswers.get(i).getQuestionId().equals(questionId)) {
                QuizAnswer oldAnswer = currentAnswers.get(i);
                quizAttempt.setScore(quizAttempt.getScore().subtract(BigDecimal.valueOf(oldAnswer.getScoreAchieved())));
                if (oldAnswer.isCorrect()) {
                    quizAttempt.setCorrectAnswers(quizAttempt.getCorrectAnswers() - 1);
                }
                quizAnswerRepository.delete(oldAnswer);
                break;
            }
        }

        quizAnswer.setQuizAttemptId(UUID.fromString(attemptId));
        // check if question submitted before
        quizAnswerRepository.save(quizAnswer);

        quizAttempt.setScore(quizAttempt.getScore().add(BigDecimal.valueOf(scoreAchieved)));
        if (isCorrect) {
            quizAttempt.setCorrectAnswers(quizAttempt.getCorrectAnswers() + 1);
        }

        // update total score
        quizAttemptRepository.save(quizAttempt);

        return new BaseCreateUpdateResponse(quizAnswer.getId().toString());
    }

# Summary: 

@Override
    public List<Quiz> getMyQuizAttempts(String userId) {
        List<QuizAttempt> attempts = quizAttemptRepository.findByUserId(UUID.fromString(userId));
        if (CollectionUtils.isEmpty(attempts)) {
            return Collections.emptyList();
        }

        Set<String> quizId = attempts.stream()
                .map(QuizAttempt::getQuizId)
                .map(UUID::toString)
                .collect(Collectors.toSet());

        List<Quiz> quizzes = quizRepository.findByIdIn(quizId);
        if (CollectionUtils.isEmpty(quizzes)) {
            return Collections.emptyList();
        }

        getQuizAuthor(quizzes);

        Map<UUID, List<QuizAttempt>> attemptMap = attempts.stream()
                .collect(Collectors.groupingBy(QuizAttempt::getQuizId));
        for (Quiz quiz : quizzes) {
            quiz.setQuizAttempts(new HashSet<>(attemptMap.get(quiz.getId())));
        }

        return quizzes;
    }

# Summary: 

@Override
    public QuizAttempt getAttempt(String attemptId, UUID userId) {
        // TODO: check permission
        QuizAttempt attempt = quizAttemptRepository.findById(attemptId).orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND));
        Quiz quiz = this.getById(attempt.getQuizId().toString());
        getQuizAuthor(Collections.singletonList(quiz));
        attempt.setQuiz(quiz);
        List<QuizAnswer> answers = quizAnswerRepository.findByQuizAttemptId(attemptId);
        attempt.setAnswers(answers);

        return attempt;
    }

# Summary: 

@Override
    public void submitQuizComplete(String attemptId, UUID id) {
        QuizAttempt attempt = quizAttemptRepository.findById(attemptId).orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND));
        if (!id.equals(attempt.getUserId())) {
            throw new BusinessException(ErrorConstant.QUIZ_ATTEMPT_NOT_BELONG_TO_USER);
        }

        if (attempt.getCompletedAt() != null) {
            throw new BusinessException(ErrorConstant.QUIZ_ATTEMPT_SUBMITTED);
        }
        attempt.setCompletedAt(LocalDateTime.now());
        quizAttemptRepository.save(attempt);
        log.info("saved quiz attempt with id: {}", attemptId);
    }

# Summary: 

@Override
    public Quiz getQuizStatsById(String id) {
        Quiz quiz = quizRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_FOUND));
        getQuizAuthor(Collections.singletonList(quiz));
        List<Question> questions = questionRepository.findByQuizId(id);
        quiz.setQuestions(new HashSet<>(questions));
        List<QuizAttempt> attempts = quizAttemptRepository.findByQuizId(quiz.getId().toString());

        attempts.forEach(attempt -> {
            userRepository.getUserById(attempt.getUserId().toString()).ifPresent(attempt::setUser);
        });

        quiz.setQuizAttempts(new HashSet<>(attempts));
        List<User> savedUsers = savedQuizRepository.findAllByQuizId(id)
                .stream()
                .map(savedQuiz -> userRepository.getUserById(savedQuiz.getUserId().toString()).orElse(null))
                .filter(Objects::nonNull)
                .toList();
        quiz.setSavedByUsers(new HashSet<>(savedUsers));

        return quiz;
    }

# Summary: 

@Override
    public void saveQuiz(String quizId, UUID userId) {
        savedQuizRepository.saveQuiz(quizId, userId.toString());
    }

# Summary: 

@Override
    public List<Quiz> getSavedQuizzes(UUID userId) {
        List<UserSavedQuiz> savedQuizzes = savedQuizRepository.findAllByUserId(userId.toString());
        if (CollectionUtils.isEmpty(savedQuizzes)) {
            return Collections.emptyList();
        }

        Set<String> quizIds = savedQuizzes.stream()
                .map(UserSavedQuiz::getQuizId)
                .map(UUID::toString)
                .collect(Collectors.toSet());
        if (CollectionUtils.isEmpty(quizIds)) {
            return Collections.emptyList();
        }

        List<Quiz> quizzes = quizRepository.findByIdIn(quizIds);
        if (CollectionUtils.isEmpty(quizzes)) {
            return Collections.emptyList();
        }

        getQuizAuthor(quizzes);

        return quizzes;
    }

# Summary: 

@Override
    public void unsaveQuiz(String quizId, UUID userId) {
        UserSavedQuiz savedQuiz = savedQuizRepository.findAllByQuizId(quizId)
                .stream()
                .filter(q -> q.getUserId().equals(userId))
                .findFirst()
                .orElseThrow(() -> new BusinessException(ErrorConstant.QUIZ_NOT_SAVED));

        savedQuiz.setSavedAt(LocalDateTime.now());
        savedQuiz.setDeletedAt(null);
        savedQuizRepository.update(savedQuiz);
    }

# Summary: 

@Override
    public List<UserSavedQuiz> getUserSavedQuiz(String quizId, UUID userId) {
        List<UserSavedQuiz> savedQuizzes = savedQuizRepository.findAllByUserId(userId.toString());
        savedQuizzes.forEach(savedQuiz -> {
            userRepository.getUserById(savedQuiz.getUserId().toString()).ifPresent(savedQuiz::setUser);
        });
        return savedQuizzes;
    }

# Summary: 

private void getQuizAuthor(List<Quiz> quizzes) {
        quizzes.forEach(q -> {
            if (q.getAuthorId() != null) {
                q.setAuthor(userRepository.getUserById(q.getAuthorId().toString()).orElse(null));
            }
        });
    }

'baseService':
# Summary: 

public String getMessage(BusinessError error) {
        return ObjectUtils.isEmpty(error.getMessage()) ? getMessage(error.getCode()) : error.getMessage();
    }

# Summary: 

public String getRequestStringValue(String key) {
        return getRequestValue(key, String.class);
    }

# Summary: 

public Object getRequestBody() {
        return getRequestValue(RequestKeyConstant.REQUEST_BODY);
    }

# Summary: 

public <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        return BaseResponse.ofGetListSucceeded(data, requestList);
    }

# Summary: 

public <T> BaseResponse<T> ofFailed(int errorCode, T data) {
        return BaseResponse.ofFailed(getRequestId(), getBusinessError(errorCode), data);
    }

# Summary: 

public BusinessError getBusinessError(int errorCode) {
        return BusinessError.builder()
                .code(errorCode)
                .message(getMessage(errorCode))
                .build();
    }

# Summary: 

public HttpHeaders getHeaders() {
        HttpHeaders headers = new HttpHeaders();
        Enumeration<String> headerNames = httpServletRequest.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = httpServletRequest.getHeader(headerName);
            headers.add(headerName, headerValue);
        }
        return headers;
    }

# Summary: 

public int getErrorCode(String errorCode, int errorCodeDefault) {
        try {
            return Integer.parseInt(errorCode);
        } catch (NumberFormatException e) {
            return errorCodeDefault;
        }
    }

'UserPrincipal':
# Summary: 

@Override
    public Collection<? extends GrantedAuthority> getAuthorities(){
        return roles.stream()
                .map(SimpleGrantedAuthority::new)
                .toList();
    }

# Summary: 

public static UserPrincipal from(User user) {
        return UserPrincipal.builder()
                .id(UUID.fromString(user.getId().toString()))
                .username(user.getUsername())
                .email(user.getEmail())
                .password(user.getCredentials().getPasswordHash())
                .roles(List.of(user.getRole().toString()))
                .build();
    }

# Summary: 

@Override
    public String getPassword() {
        return password;
    }

# Summary: 

@Override
    public String getUsername() {
        return username;
    }

# Summary: 

@Override
    public boolean isAccountNonExpired() {
        return true;
    }

# Summary: 

@Override
    public boolean isAccountNonLocked() {
        return true;
    }

# Summary: 

@Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

# Summary: 

@Override
    public boolean isEnabled() {
        return true;
    }

'BaseResponse':
# Summary: 

public static void verifyMetaResponse(BaseResponse<?> baseResponse, HttpStatus httpStatus, int status) {
        if (Objects.isNull(baseResponse) || Objects.isNull(baseResponse.meta)) {
            return;
        }

        Meta meta = baseResponse.meta;
        if (status != meta.getCode()) {
            throw new BusinessException(meta.getCode(), meta.getMessage(), httpStatus);
        }
    }

# Summary: 

public static <T> BaseResponse<T> ofFailed(String requestId, BusinessException exception, T data) {
        BaseResponse<T> response = ofFailed(exception, data);
        response.meta.setRequestId(requestId);
        response.data = data;
        return response;
    }

# Summary: 

public static <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        BaseResponse<T> response = ofSucceeded(data);
        response.meta.setRequestId(requestList.getRequestId());
        response.meta.setPageSize(requestList.getPageSize());
        response.meta.setPageIndex(requestList.getPageIndex());
        response.meta.setTotalItems(requestList.getTotalItems());
        response.data = data;
        return response;
    }

'PronunciationAccuracyRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PronunciationAccuracyRequestDto {
    private String base64Audio;
    private String text;
}

@PostMapping("/accuracy")
    public BaseResponse<Object> getAccuracy(@RequestBody PronunciationAccuracyRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getAccuracy(request));

@RestController
@RequestMapping("/api/v1/pub/pronunciations")
public class PronunciationController {
    private final BaseService baseService;
    private final PronunciationService pronunciationService;
    public PronunciationController(BaseService baseService, PronunciationService pronunciationService) {
        this.baseService = baseService;
        this.pronunciationService = pronunciationService;
    @GetMapping("/samples")
    public BaseResponse<Object> getSamplePronunciations(GetSampleRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getSample(request));

'PronunciationAccuracyRequest':
@Data
public class PronunciationAccuracyRequest {
    private String base64Audio;
    private String language;
    @JsonProperty("title")
    private String text;

'PronunciationAccuracyResponse':
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@Data
public class PronunciationAccuracyResponse {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

'PronunciationMapper':
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'PronunciationFeignClient':
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'GetSampleRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleRequestDto {
    @NotNull
    private PronunciationLevel level;
    private String customText;
}

public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'GetSampleRequest':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
public class GetSampleRequest {
    private String category;
    private String language;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String transcript;

public abstract String getFileUrl(String fileName);

'GetSampleResponse':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleResponse {
    @JsonProperty("ipa_transcript")
    private String ipaTranscript;
    @JsonProperty("real_transcript")
    private String realTranscript;
    @JsonProperty("transcript_translation")
    private String transcriptTranslation;

public abstract String getFileUrl(String fileName);

'GetPronunciationSampleResponseDto':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetPronunciationSampleResponseDto {
    private String ipaTranscript;
    private String realTranscript;
    private String transcriptTranslation;

'/api/v1/pub/pronunciations/analyze':
# Summary: 
@PostMapping("/accuracy")
    public BaseResponse<Object> getAccuracy(@RequestBody PronunciationAccuracyRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getAccuracy(request));
    }

'BusinessException':
# Summary: 

@ExceptionHandler(BusinessException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleBusinessException(BusinessException exception) {
        exception.getError().setMessage(getMessage(exception.getError()));
        Object dataException = exception.getError().getData();
        BaseResponse<?> data = ofFailed(exception);
        if(!ObjectUtils.isEmpty(dataException) && dataException instanceof String) {
            data.getMeta().setErrors(Collections.singletonList(
                ErrorViolation.builder().description((String) dataException).build()));
        }
        return new ResponseEntity<>(data, exception.getError().getHttpStatus() == null
                ? HttpStatus.OK : exception.getError().getHttpStatus());
    }

'ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR':
# Summary: 
@Data
@Accessors(chain = true)
@AllArgsConstructor
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@SuperBuilder
public class ErrorViolation {
    private String field;
    private String code;
    private String description;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

@Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();

'ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

'ErrorConstant.QUIZ_NOT_FOUND':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String deleteFile(String fileName);

public abstract String getFileUrl(String fileName);

'ErrorConstant.QUIZ_ATTEMPT_NOT_FOUND':
# Summary: 
@PostMapping("/{id}/attempts")
    @LogsActivityAnnotation
    BaseResponse<?> attemptQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.startQuiz(id, currentUser.getId()));
    }

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'ErrorConstant.QUIZ_ATTEMPT_SUBMITTED':
# Summary: 
@PostMapping("/{id}/attempts")
    @LogsActivityAnnotation
    BaseResponse<?> attemptQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.startQuiz(id, currentUser.getId()));
    }

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'ErrorConstant.QUIZ_TIME_LIMIT_EXCEEDED':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@PostMapping("/{id}/attempts")
    BaseResponse<?> attemptQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.startQuiz(id, currentUser.getId()));

'ErrorConstant.QUESTION_NOT_FOUND':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String deleteFile(String fileName);

public abstract byte[] downloadFile(String fileName);

'ErrorConstant.QUESTION_DOES_NOT_BELONG_TO_QUIZ':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public BaseResponse ofFailed(BusinessError error, String message) {
        return BaseResponse.ofFailed(getRequestId(), error, message);

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

'ErrorConstant.QUIZ_ATTEMPT_NOT_BELONG_TO_USER':
# Summary: 
@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.getByUsernameForAuth(username).orElseThrow(() -> new BusinessException(ErrorConstant.UNAUTHORIZED));
        return UserPrincipal.from(user);
    }

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public BaseResponse ofFailed(BusinessError error, String message) {
        return BaseResponse.ofFailed(getRequestId(), error, message);

'ErrorConstant.QUIZ_NOT_SAVED':
# Summary: 
@GetMapping("/save")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getSavedQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getSavedQuizzes(currentUser.getId()));
    }

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'resourceService':
# Summary: 

@Override
    public Resource uploadResource(MultipartFile file, UUID requestId) {

        String url = storageService.uploadFile(file);

        Resource resource = Resource.builder()
                .name(file.getOriginalFilename())
                .url(url)
                .ownerId(requestId)
                .extension(file.getContentType())
                .sizeBytes(file.getSize())
                .cloudId(storageService.getProviderName())
                .build();
        resourceRepository.save(resource);
        return resource;
    }

# Summary: 

@Override
    public GetResourceResponse getResource(String id, UUID requestId) {
        Resource resource = resourceRepository.findById(requestId.toString());

        if (Objects.isNull(resource)) {
            throw new RuntimeException("Resource not found");
        }

        try {
            if (!requestId.equals(resource.getOwnerId())) {
                throw new RuntimeException("You are not allowed to access this resource");
            }

            String url = storageService.getFileUrl(resource.getUrl());

            return GetResourceResponse.builder()
                    .name(resource.getName())
                    .url(url)
                    .build();

        } catch (Exception e) {
            log.info("Generate url failed {}", e.getMessage());
            throw new RuntimeException("Generate url failed");
        }
    }

# Summary: 

@Override
    public File downloadResourceFromUrl(String urlString) {
        try {
            URI uri = URI.create(urlString);
            URL url = uri.toURL();

            String fileName = Path.of(uri.getPath()).getFileName().toString();
            File outputFile = File.createTempFile("download_", "_" + fileName);

            try (InputStream in = url.openStream();
                 FileOutputStream out = new FileOutputStream(outputFile)) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = in.read(buffer)) != -1) {
                    out.write(buffer, 0, bytesRead);
                }
            }

            return outputFile;

        } catch (IOException e) {
            throw new RuntimeException("Failed to download file from URL: " + urlString, e);
        }
    }

'FileUtils':
# Summary: 

public static String convertToBase64(File file) {
        try {
            byte[] fileContent = Files.readAllBytes(file.toPath());
            return Base64.getEncoder().encodeToString(fileContent);
        } catch (Exception e) {
            log.warn("failed to convert file to Base64: {}", e.getMessage());
            return null;
        }
    }

'JsonUtils':
# Summary: 

public static <T> T getGenericObject(Object input, Class<T> clazz) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);
            return objectMapper.convertValue(input, clazz);
        } catch (Exception e) {
            return null;
        }
    }

# Summary: 

public static  <T> T getEntityFromJsonStr(String input, Class<T> clazz) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);
            return objectMapper.readValue(input, clazz);
        } catch (IOException e) {
            return null;
        }
    }

# Summary: 

public static String convertObjectToString(Object obj) throws JsonProcessingException {
        return new ObjectMapper().writeValueAsString(obj);
    }

# Summary: 

public static String toJsonString(Object input) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            return objectMapper.writeValueAsString(input);
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
    }

# Summary: 

public static <T> T readObject(String input, Class<T> clazz) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return objectMapper.readValue(input, clazz);
    }

# Summary: 

public static <T> T  readListObject(Object input, Class<T> clazz) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return objectMapper.readValue(objectMapper.writeValueAsString(input),
                objectMapper.getTypeFactory().constructCollectionType(List.class, clazz));
    }

'Quiz':
# Summary: 

@PostMapping
    @LogsActivityAnnotation
    BaseResponse<?> createQuiz(@RequestBody CreateQuizDto request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.createQuiz(request, currentUser.getId()));
    }

# Summary: 

@PutMapping
    @LogsActivityAnnotation
    BaseResponse<?> updateQuiz(@RequestBody CreateQuizDto request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.updateQuiz(request));
    }

# Summary: 

@GetMapping("/{id}")
    @LogsActivityAnnotation
    BaseResponse<Quiz> getQuizById(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getById(id));
    }

# Summary: 

@GetMapping("/{id}/stats")
    @LogsActivityAnnotation
    BaseResponse<Quiz> getQuizStatsById(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getQuizStatsById(id));
    }

# Summary: 

@DeleteMapping("/{id}")
    @LogsActivityAnnotation
    BaseResponse<?> deleteQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        quizService.deleteQuiz(id);
        return baseService.ofSucceeded(null);
    }

# Summary: 

@PostMapping("/{id}/save")
    @LogsActivityAnnotation
    BaseResponse<?> saveQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        quizService.saveQuiz(id, currentUser.getId());
        return baseService.ofSucceeded(null);
    }

# Summary: 

@DeleteMapping("/{id}/save")
    @LogsActivityAnnotation
    BaseResponse<?> unsaveQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        quizService.unsaveQuiz(id, currentUser.getId());
        return baseService.ofSucceeded(null);
    }

# Summary: 

@GetMapping("/{id}/save")
    @LogsActivityAnnotation
    BaseResponse<List<UserSavedQuiz>> getListUserSavedQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getUserSavedQuiz(id, currentUser.getId()));
    }

# Summary: 

@GetMapping("/save")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getSavedQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getSavedQuizzes(currentUser.getId()));
    }

# Summary: 

@PostMapping("/{id}/attempts")
    @LogsActivityAnnotation
    BaseResponse<?> attemptQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.startQuiz(id, currentUser.getId()));
    }

# Summary: 

@GetMapping("/attempts/{id}")
    @LogsActivityAnnotation
    BaseResponse<QuizAttempt> getQuizAttempt(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getAttempt(id, currentUser.getId()));
    }

# Summary: 

@PostMapping("/attempts/{attempt_id}/submit-question")
    @LogsActivityAnnotation
    BaseResponse<?> submitQuizQuestion(@PathVariable String attempt_id, @RequestBody SubmitAnswerRequest request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.submitQuizQuestion(attempt_id, request, currentUser.getId()));
    }

# Summary: 

@PostMapping("/attempts/{attempt_id}/complete")
    @LogsActivityAnnotation
    BaseResponse<?> submitQuizComplete(@PathVariable String attempt_id, @CurrentUser UserPrincipal currentUser) {
        quizService.submitQuizComplete(attempt_id, currentUser.getId());
        return baseService.ofSucceeded(null);
    }

# Summary: 

@GetMapping
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getAllQuizzes(@CurrentUser UserPrincipal currentUser) {
        return BaseResponse.ofSucceeded(quizService.getAllPublicQuizzes());
    }

# Summary: 

@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserSavedQuizId that = (UserSavedQuizId) o;
        return Objects.equals(userId, that.userId) &&
                Objects.equals(quizId, that.quizId);
    }

# Summary: 

@Override
    public int hashCode() {
        return Objects.hash(userId, quizId);
    }

# Summary: 

@Override
    @Transactional(readOnly = true)
    public List<Question> findByQuizId(String quizId) {
        return repository.findByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public Integer countByQuizId(String quizId) {
        return repository.countByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public QuizAnswer save(QuizAnswer answer) {
        return repository.save(answer);
    }

# Summary: 

@Override
    public void saveAll(List<QuizAnswer> answers) {
        repository.saveAll(answers);
    }

# Summary: 

@Override
    public Optional<QuizAnswer> findById(String id) {
        return repository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<QuizAnswer> findByQuizAttemptId(String attemptId) {
        return repository.findByQuizAttemptId(UUID.fromString(attemptId));
    }

# Summary: 

@Override
    public void delete(QuizAnswer oldAnswer) {
        repository.delete(oldAnswer);
    }

# Summary: 

@Override
    public QuizAttempt save(QuizAttempt attempt) {
        return jpaQuizAttemptRepository.save(attempt);
    }

# Summary: 

@Override
    public Optional<QuizAttempt> findById(String id) {
        return jpaQuizAttemptRepository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<QuizAttempt> findAll() {
        return jpaQuizAttemptRepository.findAll();
    }

# Summary: 

@Override
    public List<QuizAttempt> findByUserId(UUID id) {
        return jpaQuizAttemptRepository.findByUserId(id);
    }

# Summary: 

@Override
    public List<QuizAttempt> findByQuizId(String id) {
        return jpaQuizAttemptRepository.findByQuizId(UUID.fromString(id));
    }

# Summary: 

@Override
    public void save(Quiz quiz) {
        repository.save(quiz);
    }

# Summary: 

@Override
    public Optional<Quiz> findById(String id) {
        return repository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<Quiz> findAll() {
        return repository.findAll();
    }

# Summary: 

@Override
    public List<Quiz> findByUserId(UUID id) {
        return repository.findByAuthorId(id);
    }

# Summary: 

@Override
    public List<Quiz> findByIdIn(Set<String> quizId) {
        return repository.findByIdIn(quizId.stream()
                .map(UUID::fromString)
                .toList());
    }

# Summary: 

@Override
    public List<Quiz> findAllPublic() {
        return repository.findByStatus(QuizStatus.PUBLIC);
    }

# Summary: 

@Override
    public void saveQuiz(String quizId, String userId) {
        UserSavedQuiz savedQuiz = new UserSavedQuiz();
        savedQuiz.setSavedAt(LocalDateTime.now());
        savedQuiz.setQuizId(UUID.fromString(quizId));
        savedQuiz.setUserId(UUID.fromString(userId));
        jpaSavedQuizRepository.save(savedQuiz);
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByUserId(String userId) {
        return jpaSavedQuizRepository.findByUserId(UUID.fromString(userId));
    }

# Summary: 

@Override
    public void deleteByQuizIdAndUserId(String quizId, String userId) {
        jpaSavedQuizRepository.deleteByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public boolean existsByQuizIdAndUserId(String quizId, String userId) {
        return jpaSavedQuizRepository.existsByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByQuizId(String quizId) {
        return jpaSavedQuizRepository.findAllByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public void update(UserSavedQuiz savedQuiz) {
        jpaSavedQuizRepository.save(savedQuiz);
    }

'QuizAttempt':
# Summary: 

@GetMapping("/attempts/{id}")
    @LogsActivityAnnotation
    BaseResponse<QuizAttempt> getQuizAttempt(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getAttempt(id, currentUser.getId()));
    }

# Summary: 

@Override
    public List<QuizAnswer> findByQuizAttemptId(String attemptId) {
        return repository.findByQuizAttemptId(UUID.fromString(attemptId));
    }

# Summary: 

@Override
    public QuizAttempt save(QuizAttempt attempt) {
        return jpaQuizAttemptRepository.save(attempt);
    }

# Summary: 

@Override
    public Optional<QuizAttempt> findById(String id) {
        return jpaQuizAttemptRepository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<QuizAttempt> findAll() {
        return jpaQuizAttemptRepository.findAll();
    }

# Summary: 

@Override
    public List<QuizAttempt> findByUserId(UUID id) {
        return jpaQuizAttemptRepository.findByUserId(id);
    }

# Summary: 

@Override
    public List<QuizAttempt> findByQuizId(String id) {
        return jpaQuizAttemptRepository.findByQuizId(UUID.fromString(id));
    }

'Question':
# Summary: 

@PostMapping("/attempts/{attempt_id}/submit-question")
    @LogsActivityAnnotation
    BaseResponse<?> submitQuizQuestion(@PathVariable String attempt_id, @RequestBody SubmitAnswerRequest request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.submitQuizQuestion(attempt_id, request, currentUser.getId()));
    }

# Summary: 

@Override
    public Question save(Question question) {
        return repository.save(question);
    }

# Summary: 

@Override
    @Transactional(readOnly = true)
    public Optional<Question> findById(String id) {
        return repository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    @Transactional(readOnly = true)
    public List<Question> findByQuizId(String quizId) {
        return repository.findByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public void saveAll(List<Question> questions) {
        repository.saveAll(questions);
    }

# Summary: 

@Override
    public void deleteAll(List<Question> questions) {
        repository.deleteAll(questions);
    }

# Summary: 

@Override
    public Integer countByQuizId(String quizId) {
        return repository.countByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public BaseCreateUpdateResponse createQuestion(QuestionDto request, UUID authorId) {
        return null;
    }

# Summary: 

@Override
    public BaseCreateUpdateResponse updateQuestion(QuestionDto request) {
        return null;
    }

# Summary: 

@Override
    public List<Question> getAllQuestions() {
        return List.of();
    }

# Summary: 

@Override
    public List<Question> getMyQuestions(UUID id) {
        return List.of();
    }

# Summary: 

@Override
    public Question getById(String id) {
        return null;
    }

# Summary: 

@Override
    public void deleteQuestion(String id) {

    }

'QuestionOption':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
public class QuestionOption {
    private UUID id;
    private Boolean isCorrect;
    private String text;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'QuestionDto':
# Summary: 
@Data
public class QuestionDto {
    private String id;
    private QuestionType type;
    private String text;
    private List<OptionDto> options;
    private String pronunciationText;
    private List<String> correctBlanks;
    private Boolean trueFalseAnswer;
    private String audioUrl;
    private String imageUrl;
    private Integer maxListeningTime;
    private int points;
    private Difficulty difficulty;
    private Integer acceptRate;
    private String category;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getProviderName();

'CreateQuizDto':
# Summary: 
@Data
public class CreateQuizDto {
    private String id;
    private String title;
    private String description;
    private List<QuestionDto> questions;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private Integer totalPoints;
    private String difficulty;
    private Integer estimatedDuration;
    private List<String> tags;
    private Boolean isPublic;
    private Integer version;
    private QuizNavigationMode navigationMode;
    private Boolean hasTimer;
    private Integer timeLimit;
    private Integer warningTime;
    private Boolean allowQuestionPicker;
    private Boolean shuffleQuestions;
    private Boolean shuffleAnswers;
    private Boolean showProgress;
    private Boolean allowPause;
    private Integer maxAttempts;
    private Integer passingScore;
}

@PostMapping
    @LogsActivityAnnotation
    BaseResponse<?> createQuiz(@RequestBody CreateQuizDto request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.createQuiz(request, currentUser.getId()));

@PutMapping
    BaseResponse<?> updateQuiz(@RequestBody CreateQuizDto request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.updateQuiz(request));

'BaseCreateUpdateResponse':
# Summary: 
@Data
@AllArgsConstructor
@NoArgsConstructor
public class BaseCreateUpdateResponse {
    private String id;
}

@Override
    public BaseCreateUpdateResponse createQuestion(QuestionDto request, UUID authorId) {
        return null;

    public BaseCreateUpdateResponse updateQuestion(QuestionDto request) {

'QuizRepository':
# Summary: 

@Override
    public void save(Quiz quiz) {
        repository.save(quiz);
    }

# Summary: 

@Override
    public Optional<Quiz> findById(String id) {
        return repository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<Quiz> findAll() {
        return repository.findAll();
    }

# Summary: 

@Override
    public List<Quiz> findByUserId(UUID id) {
        return repository.findByAuthorId(id);
    }

# Summary: 

@Override
    public List<Quiz> findByIdIn(Set<String> quizId) {
        return repository.findByIdIn(quizId.stream()
                .map(UUID::fromString)
                .toList());
    }

# Summary: 

@Override
    public List<Quiz> findAllPublic() {
        return repository.findByStatus(QuizStatus.PUBLIC);
    }

# Summary: 

@Override
    public void saveQuiz(String quizId, String userId) {
        UserSavedQuiz savedQuiz = new UserSavedQuiz();
        savedQuiz.setSavedAt(LocalDateTime.now());
        savedQuiz.setQuizId(UUID.fromString(quizId));
        savedQuiz.setUserId(UUID.fromString(userId));
        jpaSavedQuizRepository.save(savedQuiz);
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByUserId(String userId) {
        return jpaSavedQuizRepository.findByUserId(UUID.fromString(userId));
    }

# Summary: 

@Override
    public void deleteByQuizIdAndUserId(String quizId, String userId) {
        jpaSavedQuizRepository.deleteByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public boolean existsByQuizIdAndUserId(String quizId, String userId) {
        return jpaSavedQuizRepository.existsByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByQuizId(String quizId) {
        return jpaSavedQuizRepository.findAllByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public void update(UserSavedQuiz savedQuiz) {
        jpaSavedQuizRepository.save(savedQuiz);
    }

'QuestionRepository':
# Summary: 

@Override
    public Question save(Question question) {
        return repository.save(question);
    }

# Summary: 

@Override
    @Transactional(readOnly = true)
    public Optional<Question> findById(String id) {
        return repository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    @Transactional(readOnly = true)
    public List<Question> findByQuizId(String quizId) {
        return repository.findByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public void saveAll(List<Question> questions) {
        repository.saveAll(questions);
    }

# Summary: 

@Override
    public void deleteAll(List<Question> questions) {
        repository.deleteAll(questions);
    }

# Summary: 

@Override
    public Integer countByQuizId(String quizId) {
        return repository.countByQuizId(UUID.fromString(quizId));
    }

'QuizAttemptRepository':
# Summary: 

@Override
    public QuizAttempt save(QuizAttempt attempt) {
        return jpaQuizAttemptRepository.save(attempt);
    }

# Summary: 

@Override
    public Optional<QuizAttempt> findById(String id) {
        return jpaQuizAttemptRepository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<QuizAttempt> findAll() {
        return jpaQuizAttemptRepository.findAll();
    }

# Summary: 

@Override
    public List<QuizAttempt> findByUserId(UUID id) {
        return jpaQuizAttemptRepository.findByUserId(id);
    }

# Summary: 

@Override
    public List<QuizAttempt> findByQuizId(String id) {
        return jpaQuizAttemptRepository.findByQuizId(UUID.fromString(id));
    }

'QuizAnswerRepository':
# Summary: 

@Override
    public QuizAnswer save(QuizAnswer answer) {
        return repository.save(answer);
    }

# Summary: 

@Override
    public void saveAll(List<QuizAnswer> answers) {
        repository.saveAll(answers);
    }

# Summary: 

@Override
    public Optional<QuizAnswer> findById(String id) {
        return repository.findById(UUID.fromString(id));
    }

# Summary: 

@Override
    public List<QuizAnswer> findByQuizAttemptId(String attemptId) {
        return repository.findByQuizAttemptId(UUID.fromString(attemptId));
    }

# Summary: 

@Override
    public void delete(QuizAnswer oldAnswer) {
        repository.delete(oldAnswer);
    }

'UserRepository':
# Summary: 

@Override
    public Optional<User> getUserById(String userId) {
        return repository.findById(UUID.fromString(userId));
    }

# Summary: 

@Override
    public Optional<User> getByUsername(String username) {
        return repository.findByUsername(username);
    }

# Summary: 

@Override
    public Optional<User> getByUsernameForAuth(String username) {
        Optional<User> user = repository.findByUsername(username);
        if (user.isPresent()) {
            UserCredential credentials = userCredentialRepository.findByUserId(user.get().getId());
            user.get().setCredentials(credentials);
            return user;
        }
        return Optional.empty();
    }

# Summary: 

@Override
    public User persist(User user) {
        User userRes = repository.save(user);
        UserCredential credentials = user.getCredentials();
        credentials.setUserId(userRes.getId());
        userCredentialRepository.save(credentials);
        return userRes;
    }

# Summary: 

@Override
    public List<User> getByUserIdList(List<UUID> studentIds) {
        return repository.findAllById(studentIds);
    }

# Summary: 

@Override
    public List<BasicUserDto> basicSearch(String keyword) {
        return List.of();
    }

# Summary: 

@Override
    public Optional<User> getByEmail(String email) {
        return repository.findByEmail(email);
    }

'SavedQuizRepository':
# Summary: 

@Override
    public void saveQuiz(String quizId, String userId) {
        UserSavedQuiz savedQuiz = new UserSavedQuiz();
        savedQuiz.setSavedAt(LocalDateTime.now());
        savedQuiz.setQuizId(UUID.fromString(quizId));
        savedQuiz.setUserId(UUID.fromString(userId));
        jpaSavedQuizRepository.save(savedQuiz);
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByUserId(String userId) {
        return jpaSavedQuizRepository.findByUserId(UUID.fromString(userId));
    }

# Summary: 

@Override
    public void deleteByQuizIdAndUserId(String quizId, String userId) {
        jpaSavedQuizRepository.deleteByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public boolean existsByQuizIdAndUserId(String quizId, String userId) {
        return jpaSavedQuizRepository.existsByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByQuizId(String quizId) {
        return jpaSavedQuizRepository.findAllByQuizId(UUID.fromString(quizId));
    }

# Summary: 

@Override
    public void update(UserSavedQuiz savedQuiz) {
        jpaSavedQuizRepository.save(savedQuiz);
    }

'UserSavedQuiz':
# Summary: 

@GetMapping("/{id}/save")
    @LogsActivityAnnotation
    BaseResponse<List<UserSavedQuiz>> getListUserSavedQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getUserSavedQuiz(id, currentUser.getId()));
    }

# Summary: 

@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserSavedQuizId that = (UserSavedQuizId) o;
        return Objects.equals(userId, that.userId) &&
                Objects.equals(quizId, that.quizId);
    }

# Summary: 

@Override
    public int hashCode() {
        return Objects.hash(userId, quizId);
    }

'SubmitAnswerRequest':
# Summary: 
@Data
public class SubmitAnswerRequest {
    private String questionId;
    private List<String> selectedOptions;
    private List<String> fillInBlanksAnswers;
    private String answerText;
    private Boolean userAnswerTrueFalse;
    private Integer timeTaken;
    private String audioUrl;
}

@PostMapping("/attempts/{attempt_id}/submit-question")
    @LogsActivityAnnotation
    BaseResponse<?> submitQuizQuestion(@PathVariable String attempt_id, @RequestBody SubmitAnswerRequest request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.submitQuizQuestion(attempt_id, request, currentUser.getId()));

@RestController
@RequestMapping("/api/v1/quizzes")
public class QuizController {
    private final QuizService quizService;
    private final BaseService baseService;
    public QuizController(QuizService quizService, BaseService baseService) {
        this.quizService = quizService;
        this.baseService = baseService;
    @PostMapping
    BaseResponse<?> createQuiz(@RequestBody CreateQuizDto request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.createQuiz(request, currentUser.getId()));
    @PutMapping
    BaseResponse<?> updateQuiz(@RequestBody CreateQuizDto request, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.updateQuiz(request));
    @GetMapping("/{id}")
    BaseResponse<Quiz> getQuizById(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getById(id));
    @GetMapping("/{id}/stats")
    BaseResponse<Quiz> getQuizStatsById(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getQuizStatsById(id));
    @GetMapping("/my")
    BaseResponse<List<Quiz>> getMyQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizzes(currentUser.getId()));
    @DeleteMapping("/{id}")
    BaseResponse<?> deleteQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        quizService.deleteQuiz(id);
        return baseService.ofSucceeded(null);
    @PostMapping("/{id}/save")
    BaseResponse<?> saveQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        quizService.saveQuiz(id, currentUser.getId());
        return baseService.ofSucceeded(null);
    @DeleteMapping("/{id}/save")
    BaseResponse<?> unsaveQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        quizService.unsaveQuiz(id, currentUser.getId());
        return baseService.ofSucceeded(null);
    @GetMapping("/{id}/save")
    BaseResponse<List<UserSavedQuiz>> getListUserSavedQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getUserSavedQuiz(id, currentUser.getId()));
    @GetMapping("/save")
    BaseResponse<List<Quiz>> getSavedQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getSavedQuizzes(currentUser.getId()));
    @PostMapping("/{id}/attempts")
    BaseResponse<?> attemptQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.startQuiz(id, currentUser.getId()));
    @GetMapping("/attempts")
    BaseResponse<List<Quiz>> getQuizAttempts(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizAttempts(currentUser.getId().toString()));
    @GetMapping("/attempts/{id}")
    BaseResponse<QuizAttempt> getQuizAttempt(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getAttempt(id, currentUser.getId()));
    @PostMapping("/attempts/{attempt_id}/complete")
    BaseResponse<?> submitQuizComplete(@PathVariable String attempt_id, @CurrentUser UserPrincipal currentUser) {
        quizService.submitQuizComplete(attempt_id, currentUser.getId());
        return baseService.ofSucceeded(null);

'QuestionType':
# Summary: 
@Data
public class QuestionDto {
    private String id;
    private QuestionType type;
    private String text;
    private List<OptionDto> options;
    private String pronunciationText;
    private List<String> correctBlanks;
    private Boolean trueFalseAnswer;
    private String audioUrl;
    private String imageUrl;
    private Integer maxListeningTime;
    private int points;
    private Difficulty difficulty;
    private Integer acceptRate;
    private String category;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'LocalDateTime':
# Summary: 

public static LocalDateTime stringToLocalDateTime(String dateOfBirth) {
        if (StringUtils.isBlank(dateOfBirth)) {
            return null;
        }
        return LocalDateTime.parse(dateOfBirth);
    }

'UUID':
# Summary: 
@Data
public class OptionDto {
    private UUID id;
    private String text;
    private Boolean isCorrect;
}

@Override
    public BaseCreateUpdateResponse createQuestion(QuestionDto request, UUID authorId) {
        return null;

'BigDecimal':
# Summary: 
@Entity
@Table(name = "leaderboard")
@Data
@NoArgsConstructor
@AllArgsConstructor
@IdClass(LeaderboardEntryId.class)
public class LeaderboardEntry {
    @Id
    @Column(name = "quiz_id", nullable = false)
    private UUID quizId;
    @Id
    @Column(name = "user_id", nullable = false)
    private UUID userId;
    @Column(name = "score", precision = 5, scale = 2)
    private BigDecimal score;
    @Column(name = "completion_time")
    private Integer completionTime;
    @Column(name = "accuracy", precision = 3, scale = 2)
    private BigDecimal accuracy;
    @Column(name = "attempts")
    private Integer attempts;
    @Column(name = "last_attempt")
    private LocalDateTime lastAttempt;
    @Column(name = "rank")
    private Integer rank;
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    @Transient
    private Quiz quiz;
    @Transient
    private User user;
}

@Table(name = "quiz_attempts")
public class QuizAttempt {
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;
    private List<QuizAnswer> answers;
    @Column(name = "total_questions")
    private Integer totalQuestions;
    @Column(name = "correct_answers")
    private Integer correctAnswers;
    @Column(name = "time_spent")
    private Long timeSpent;
    @Column(name = "completed_at")
    private LocalDateTime completedAt;
    @Column(name = "passed")
    private Boolean passed;
    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

@Table(name = "quizzes")
public class Quiz {
    @Column(name = "title")
    private String title;
    @Column(name = "description")
    private String description;
    @Column(name = "category")
    private String category;
    @Column(name = "difficulty")
    private String difficulty;
    @Column(name = "duration")
    private Integer duration;
    @Column(name = "question_count")
    private Integer questionCount = 0;
    @Column(name = "tags", columnDefinition = "text[]")
    @Type(ListArrayType.class)
    private List<String> tags = new ArrayList<>();
    @Column(name = "status")
    @Enumerated(EnumType.STRING)
    private QuizStatus status;
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    @Column(name = "author_id") // This is the ID field for the conceptual author
    private UUID authorId;
    private User author;
    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating = BigDecimal.valueOf(0.00);
    private Integer attempts = 0;
    @Column(name = "passing_score")
    private Integer passingScore;
    @Column(name = "navigation_mode")
    private String navigationMode;
    @Column(name = "has_timer")
    private Boolean hasTimer = false;
    @Column(name = "time_limit")
    private Integer timeLimit;
    @Column(name = "warning_time")
    private Integer warningTime;
    @Column(name = "allow_question_picker")
    private Boolean allowQuestionPicker = false;
    @Column(name = "shuffle_questions")
    private Boolean shuffleQuestions = false;
    @Column(name = "shuffle_answers")
    private Boolean shuffleAnswers = false;
    @Column(name = "show_progress")
    private Boolean showProgress = false;
    @Column(name = "allow_pause")
    private Boolean allowPause = false;
    @Column(name = "max_attempts")
    private Integer maxAttempts;
    private Set<Question> questions;
    private Set<QuizAttempt> quizAttempts;
    private Set<User> savedByUsers;
    private Set<LeaderboardEntry> leaderboardEntries;

'Duration':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

public abstract String getProviderName();

'File':
# Summary: 

@Override
    public AuthProfileResponse getAuthProfile(String id) {
        User user = userRepository.getUserById(id).orElseThrow(() -> new RuntimeException("User not found"));

        return userMapper.userToAuthProfileResponse(user);
    }

# Summary: 

@Override
    public String getFileUrl(String fileName) {
        return String.format("%s/%s", domain, fileName);
    }

# Summary: 

@Override
    public String uploadFile(MultipartFile file) {
        File fileObj = null;
        try {
            fileObj = convertMultiPartFileToFile(file);
            String fileName = Objects.requireNonNull(file.getOriginalFilename()).replace(" ", "") + "_" + System.currentTimeMillis() + "."
                    + Objects.requireNonNull(file.getContentType()).split("/")[1];

            PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                    .bucket(bucketName)
                    .key(fileName)
                    .contentType(file.getContentType())
                    .build();

            s3Client.putObject(putObjectRequest, RequestBody.fromFile(fileObj));

            return getFileUrl(fileName);
        } catch (IOException e) {
            log.error("Error during file processing (conversion or deletion): {}", e.getMessage(), e);
            throw new RuntimeException("Error processing file for S3 upload", e);
        }
        catch (Exception e) {
            log.error("Error while uploading file to S3: {}", e.getMessage(), e);
            throw new RuntimeException("Error while uploading file to S3", e);
        } finally {
            if (fileObj != null && fileObj.exists()) {
                if (!fileObj.delete()) {
                    log.warn("Failed to delete temporary file: {}", fileObj.getAbsolutePath());
                }
            }
        }
    }

# Summary: 

@Override
    public byte[] downloadFile(String fileName) {
        try {
            // Build the GetObjectRequest for S3 download
            GetObjectRequest getObjectRequest = GetObjectRequest.builder()
                    .bucket(bucketName)
                    .key(fileName)
                    .build();

            // Get the object content as a ResponseInputStream and read all bytes
            ResponseInputStream<GetObjectResponse> s3Object = s3Client.getObject(getObjectRequest);
            return s3Object.readAllBytes();
        } catch (IOException e) {
            log.error("Error reading downloaded file content: {}", e.getMessage(), e);
            throw new RuntimeException("Error while reading downloaded file content", e);
        } catch (Exception e) {
            log.error("Error while downloading file from S3: {}", e.getMessage(), e);
            throw new RuntimeException("Error while downloading file from S3", e);
        }
    }

# Summary: 

@Override
    public String deleteFile(String fileName) {
        try {
            // Build the DeleteObjectRequest for S3 deletion
            DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()
                    .bucket(bucketName)
                    .key(fileName)
                    .build();
            s3Client.deleteObject(deleteObjectRequest);
            return fileName + " removed ...";
        } catch (Exception e) {
            log.error("Error while deleting file from S3: {}", e.getMessage(), e);
            throw new RuntimeException("Error while deleting file from S3", e);
        }
    }

# Summary: 

@Override
    public String getFileUrl(String fileName) {
        return String.format("%s/%s", domain, fileName);
    }

# Summary: 

@Override
    public String uploadFile(MultipartFile file) {
        File tempFile = null;
        String uploadedFileName = null;
        try {
            // Validate file presence
            if (file.isEmpty()) {
                throw new IllegalArgumentException("Cannot upload empty file.");
            }

            String originalFilename = Objects.requireNonNull(file.getOriginalFilename());
            String fileExtension = "";
            int dotIndex = originalFilename.lastIndexOf('.');
            if (dotIndex > 0 && dotIndex < originalFilename.length() - 1) {
                fileExtension = originalFilename.substring(dotIndex);
            }
            // Use UUID for robust unique naming
            uploadedFileName = UUID.randomUUID().toString() + fileExtension;

            // Convert MultipartFile to a temporary File
            tempFile = File.createTempFile("upload-", fileExtension);
            file.transferTo(tempFile);

            InputStream inputStream = new ClassPathResource(gcpCredentials).getInputStream();

            Storage storage = StorageOptions.newBuilder().setProjectId(projectId).setCredentials(GoogleCredentials.fromStream(inputStream)).build().getService();
            BlobId blobId = BlobId.of(bucketName, uploadedFileName);
            String contentType = file.getContentType() != null ? file.getContentType() : "application/octet-stream";
            BlobInfo blobInfo = BlobInfo.newBuilder(blobId)
                    .setContentType(contentType)
                    .build();

            storage.createFrom(blobInfo, Files.newInputStream(tempFile.toPath()));

            log.info("File {} uploaded to Google Cloud Storage bucket {} as {}", originalFilename, bucketName, uploadedFileName);
            return uploadedFileName;

        } catch (IOException e) {
            log.error("Error during file processing or upload to Google Cloud Storage: {}", e.getMessage(), e);
            throw new RuntimeException("Error processing file for Google Cloud Storage upload", e);
        } catch (Exception e) {
            log.error("An unexpected error occurred while uploading file to Google Cloud Storage: {}", e.getMessage(), e);
            throw new RuntimeException("An unexpected error occurred during Google Cloud Storage upload", e);
        } finally {
            // Ensure the temporary file is deleted
            if (tempFile != null && tempFile.exists()) {
                try {
                    Files.delete(tempFile.toPath());
                    log.debug("Temporary file deleted: {}", tempFile.getAbsolutePath());
                } catch (IOException e) {
                    log.warn("Failed to delete temporary file: {}", tempFile.getAbsolutePath(), e);
                }
            }
        }
    }

# Summary: 

@Override
    public byte[] downloadFile(String fileName) {
        try {
            Storage storage = StorageOptions.newBuilder().setProjectId(projectId).build().getService();
            BlobId blobId = BlobId.of(bucketName, fileName);
            return storage.readAllBytes(blobId);
        } catch (Exception e) {
            log.error("Error while downloading file {} from Google Cloud Storage: {}", fileName, e.getMessage(), e);
            throw new RuntimeException("Error while downloading file from Google Cloud Storage", e);
        }
    }

# Summary: 

@Override
    public String deleteFile(String fileName) {
        try {
            Storage storage = StorageOptions.newBuilder().setProjectId(projectId).build().getService();
            BlobId blobId = BlobId.of(bucketName, fileName);
            boolean deleted = storage.delete(blobId);

            if (deleted) {
                log.info("File {} deleted from Google Cloud Storage bucket {}", fileName, bucketName);
                return fileName + " removed ...";
            } else {
                log.warn("File {} not found in Google Cloud Storage bucket {} for deletion.", fileName, bucketName);
                return fileName + " not found or could not be deleted.";
            }
        } catch (Exception e) {
            log.error("Error while deleting file {} from Google Cloud Storage: {}", fileName, e.getMessage(), e);
            throw new RuntimeException("Error while deleting file from Google Cloud Storage", e);
        }
    }

# Summary: 

public abstract String getFileUrl(String fileName);

# Summary: 

public abstract String uploadFile(MultipartFile file);

# Summary: 

public abstract byte[] downloadFile(String fileName);

# Summary: 

public abstract String deleteFile(String fileName);

# Summary: 

protected File convertMultiPartFileToFile(MultipartFile file) throws IOException {
        String originalFilename = Objects.requireNonNull(file.getOriginalFilename());
        String name = originalFilename;
        String extension = "";
        int lastDotIndex = originalFilename.lastIndexOf(".");
        if (lastDotIndex != -1) {
            name = originalFilename.substring(0, lastDotIndex);
            extension = originalFilename.substring(lastDotIndex);
        }

        Path tempFilePath = Files.createTempFile(name + "_", extension);

        file.transferTo(tempFilePath.toFile());

        log.debug("Created temporary file: {}", tempFilePath.toAbsolutePath());
        return tempFilePath.toFile();
    }

# Summary: 

public static String convertToBase64(File file) {
        try {
            byte[] fileContent = Files.readAllBytes(file.toPath());
            return Base64.getEncoder().encodeToString(fileContent);
        } catch (Exception e) {
            log.warn("failed to convert file to Base64: {}", e.getMessage());
            return null;
        }
    }

'List':
# Summary: 

@Override
    public String convertToDatabaseColumn(List<String> stringList) {
        if (stringList == null || stringList.isEmpty()) {
            return null;
        }
        // For TEXT[], PostgreSQL expects the array literal format, e.g., "{tag1,tag2}"
        // However, Hibernate Types handles this directly. For a simple comma-separated
        // string, this converter is a fallback.
        // For true TEXT[] mapping with hibernate-types-52, you might not need this converter
        // if you use @TypeDef(name = "list-array", typeClass = ListArrayType.class)
        // and a List<String> field. But it's good for demonstration if you want manual control.
        return "{" + String.join(SPLIT_CHAR, stringList) + "}";
    }

# Summary: 

@Override
    public List<String> convertToEntityAttribute(String string) {
        if (string == null || string.isEmpty()) {
            return null;
        }
        // Remove curly braces if present from PostgreSQL array literal
        String cleanedString = string.replaceAll("^\\{|\\}$", "");
        return Arrays.asList(cleanedString.split(SPLIT_CHAR));
    }

# Summary: 

@GetMapping("/{id}/save")
    @LogsActivityAnnotation
    BaseResponse<List<UserSavedQuiz>> getListUserSavedQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getUserSavedQuiz(id, currentUser.getId()));
    }

# Summary: 

@Override
    public List<User> getByUserIdList(List<UUID> studentIds) {
        return repository.findAllById(studentIds);
    }

# Summary: 

public static <T> T  readListObject(Object input, Class<T> clazz) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return objectMapper.readValue(objectMapper.writeValueAsString(input),
                objectMapper.getTypeFactory().constructCollectionType(List.class, clazz));
    }

# Summary: 

public static <T> Map<String, T> convertListToMap(List<T> list, Function<T, String> keyExtractor) {
        return list.stream().collect(Collectors.toMap(keyExtractor, Function.identity(), (oldVal, newVal) -> newVal));
    }

'Set':
# Summary: 
@Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        HttpServletRequest request = (HttpServletRequest) req;
        // Skip health check URL
        if (request.getRequestURI().contains(HEALTH_CHECK_URL)) {
            chain.doFilter(req, res);
            return;
        }
        // Initialize requestId here to ensure it's always set
        String requestId = UUID.randomUUID().toString(); // Default if not found in header
        ThreadContext.put(THREAD_REQUEST_ID, requestId); // Always put in ThreadContext early
        try {
            // Check if it's a multipart request (e.g., file upload)
            boolean isMultipart = multipartResolver.isMultipart(request); // Use Spring's resolver directly
            if (isMultipart) {
                // Resolve the multipart request
                MultipartHttpServletRequest multipartRequest = multipartResolver.resolveMultipart(request);
                // Get or generate X-Request-ID
                String headerRequestId = multipartRequest.getHeader(X_REQUEST_ID);
                if (!ObjectUtils.isEmpty(headerRequestId)) {
                    requestId = headerRequestId;
                    ThreadContext.put(THREAD_REQUEST_ID, requestId); // Update if found in header
                }
                // Attach multipart request body to attribute
                multipartRequest.setAttribute(REQUEST_BODY, multipartRequest);
                multipartRequest.setAttribute(REQUEST_ID, requestId);
                chain.doFilter(multipartRequest, response);
            } else {
                // For non-multipart requests, wrap the request to re-read the body
                ApiKeyVerifyRequestWrapper requestWrapper = new ApiKeyVerifyRequestWrapper(request);
                // Get or generate X-Request-ID from the wrapped request
                String headerRequestId = requestWrapper.getHeader(X_REQUEST_ID);
                if (!ObjectUtils.isEmpty(headerRequestId)) {
                    requestId = headerRequestId;
                    ThreadContext.put(THREAD_REQUEST_ID, requestId); // Update if found in header
                }
                // Parse JSON body if available
                JSONObject dataRequest = new JSONObject();
                String requestBodyString = requestWrapper.getBody();
                if (!ObjectUtils.isEmpty(requestBodyString)) {
                    try {
                        JSONParser parser = new JSONParser();
                        dataRequest = (JSONObject) parser.parse(requestBodyString);
                    } catch (ParseException e) {
                        log.warn("Failed to parse request body as JSON for URI: {}. Body: {}", request.getRequestURI(), requestBodyString, e);
                        // Decide how to handle non-JSON bodies. For now, dataRequest remains empty.
                        // You might want to return 400 Bad Request here if JSON is strictly required.
                    }
                }
                // Add request metadata to JSON object and request attributes
                dataRequest.put(REQUEST_ID, requestId);
                request.setAttribute(REQUEST_ID, requestId); // Use original request for attributes if chain expects it
                dataRequest.put(API_KEY, requestWrapper.getHeader(API_KEY));
                request.setAttribute(API_KEY, requestWrapper.getHeader(API_KEY));
                dataRequest.put(API_SECRET, requestWrapper.getHeader(API_SECRET));
                request.setAttribute(API_SECRET, requestWrapper.getHeader(API_SECRET));
                // Note: request.getRequestURI() is already available from the original request
                // requestWrapper.getHeader(RequestKeyConstant.URI) doesn't make sense as URI is not a header.
                // Assuming URI is needed in dataRequest for logging/processing.
                dataRequest.put(URI, request.getRequestURI());
                request.setAttribute(URI, request.getRequestURI()); // Set actual URI
                request.setAttribute(REQUEST_PARAMETERS, request.getParameterMap()); // Parameters from original request
                request.setAttribute(REQUEST_BODY, dataRequest); // The parsed JSON body
                // The requestWrapper's body is immutable (final), so setting it here won't change
                // the stream that ApiKeyVerifyRequestWrapper provides.
                // If you intend to *modify* the body and have the modified body flow downstream,
                // you would need a more sophisticated wrapper that allows body modification
                // before constructing its InputStream/Reader.
                // For now, `requestWrapper.setBody(dataRequest.toString());` is removed
                // as `setBody` was removed in the previous step and it was modifying the internal state
                // of the wrapper, not the original request input stream for subsequent filters/servlets.
                // The `requestWrapper` already holds the *original* request body.
                chain.doFilter(requestWrapper, response);
            }
        } catch (IOException | ServletException e) {
            log.error("Filter processing error for URI: {}", request.getRequestURI(), e);
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); // Or SC_BAD_REQUEST depending on error type
        } catch (Throwable e) { // Catch all other unhandled throwables
            log.error("An unexpected error occurred in filter for URI: {}", request.getRequestURI(), e);
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        } finally {
            // Always clear ThreadContext regardless of success or failure
            ThreadContext.clearAll();
        }
    }

@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
@Slf4j // Lombok annotation for logging
public class AppCorsFilter implements Filter {
    // Spring's standard multipart resolver.
    // Autowire it if it's a bean, or create it if not.
    // For a filter, it's often configured via a Bean or WebMvcConfigurer.
    // If you explicitly add @Bean for MultipartResolver, Spring will use it.
    private final MultipartResolver multipartResolver;
    // Constructor injection for MultipartResolver
    // This is good practice for dependency injection in Spring.
    // Ensure you have a @Bean for MultipartResolver in your config, e.g.,
    // @Bean public MultipartResolver multipartResolver() { return new StandardServletMultipartResolver(); }
    public AppCorsFilter(MultipartResolver multipartResolver) {
        this.multipartResolver = multipartResolver;
    // Overloaded constructor for cases where Spring might instantiate without explicit injection,
    // although the above constructor is preferred when using @Component.
    public AppCorsFilter() {
        // Fallback for when Spring doesn't inject it via constructor.
        // In a typical Spring Boot setup, StandardServletMultipartResolver is usually auto-configured
        // if multipart properties are set (e.g., spring.servlet.multipart.enabled=true).
        // It's safer to rely on dependency injection.
        this.multipartResolver = new StandardServletMultipartResolver();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'Map':
# Summary: 

public static <T> Map<String, T> convertListToMap(List<T> list, Function<T, String> keyExtractor) {
        return list.stream().collect(Collectors.toMap(keyExtractor, Function.identity(), (oldVal, newVal) -> newVal));
    }

'HashSet':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

'ArrayList':
# Summary: 
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

'Collectors':
# Summary: 
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

'Objects':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

'CollectionUtils':
# Summary: 
public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getProviderName();

'IllegalArgumentException':
# Summary: 

@ExceptionHandler(IllegalArgumentException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleIllegalArgumentException(IllegalArgumentException exception) {
        BusinessError error = getBusinessError(ErrorConstant.INVALID_PARAMETERS);
        BaseResponse<?> data = ofFailed(error, getMessage(error), exception.getMessage());
        return new ResponseEntity<>(data, HttpStatus.OK);
    }

'EntityNotFoundException':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

public abstract String getProviderName();

'QuizStatus':
# Summary: 
@Entity
@Table(name = "quizzes")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Quiz {
    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;
    @Column(name = "title")
    private String title;
    @Column(name = "description")
    private String description;
    @Column(name = "category")
    private String category;
    @Column(name = "difficulty")
    private String difficulty;
    @Column(name = "duration")
    private Integer duration;
    @Column(name = "question_count")
    private Integer questionCount = 0;
    @Column(name = "tags", columnDefinition = "text[]")
    @Type(ListArrayType.class)
    private List<String> tags = new ArrayList<>();
    @Column(name = "status")
    @Enumerated(EnumType.STRING)
    private QuizStatus status;
    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    @Column(name = "author_id") // This is the ID field for the conceptual author
    private UUID authorId;
    @Transient
    private User author;
    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating = BigDecimal.valueOf(0.00);
    @Column(name = "attempts")
    private Integer attempts = 0;
    @Column(name = "passing_score")
    private Integer passingScore;
    @Column(name = "navigation_mode")
    private String navigationMode;
    @Column(name = "has_timer")
    private Boolean hasTimer = false;
    @Column(name = "time_limit")
    private Integer timeLimit;
    @Column(name = "warning_time")
    private Integer warningTime;
    @Column(name = "allow_question_picker")
    private Boolean allowQuestionPicker = false;
    @Column(name = "shuffle_questions")
    private Boolean shuffleQuestions = false;
    @Column(name = "shuffle_answers")
    private Boolean shuffleAnswers = false;
    @Column(name = "show_progress")
    private Boolean showProgress = false;
    @Column(name = "allow_pause")
    private Boolean allowPause = false;
    @Column(name = "max_attempts")
    private Integer maxAttempts;
    @Transient
    private Set<Question> questions;
    @Transient
    private Set<QuizAttempt> quizAttempts;
    @Transient
    private Set<User> savedByUsers;
    @Transient
    private Set<LeaderboardEntry> leaderboardEntries;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getProviderName();

No new code found for symbol: BusinessError.

'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

'LogsActivityAnnotation':
# Summary: 

@Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);

        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();

        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));

        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    }

'CurrentUser':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

public abstract String getProviderName();

'User':
# Summary: 

@GetMapping("/{id}/save")
    @LogsActivityAnnotation
    BaseResponse<List<UserSavedQuiz>> getListUserSavedQuiz(@PathVariable String id, @CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getUserSavedQuiz(id, currentUser.getId()));
    }

# Summary: 

@PutMapping
    public BaseResponse<?> uploadResource(
            @CurrentUser UserPrincipal requester
    ) {
        
        return baseService.ofSucceeded(null);
    }

# Summary: 

@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserSavedQuizId that = (UserSavedQuizId) o;
        return Objects.equals(userId, that.userId) &&
                Objects.equals(quizId, that.quizId);
    }

# Summary: 

@Override
    public int hashCode() {
        return Objects.hash(userId, quizId);
    }

# Summary: 

@Override
    public List<QuizAttempt> findByUserId(UUID id) {
        return jpaQuizAttemptRepository.findByUserId(id);
    }

# Summary: 

@Override
    public List<Quiz> findByUserId(UUID id) {
        return repository.findByAuthorId(id);
    }

# Summary: 

@Override
    public List<UserSavedQuiz> findAllByUserId(String userId) {
        return jpaSavedQuizRepository.findByUserId(UUID.fromString(userId));
    }

# Summary: 

@Override
    public void deleteByQuizIdAndUserId(String quizId, String userId) {
        jpaSavedQuizRepository.deleteByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public boolean existsByQuizIdAndUserId(String quizId, String userId) {
        return jpaSavedQuizRepository.existsByQuizIdAndUserId(UUID.fromString(quizId), UUID.fromString(userId));
    }

# Summary: 

@Override
    public Optional<User> getUserById(String userId) {
        return repository.findById(UUID.fromString(userId));
    }

# Summary: 

@Override
    public Optional<User> getByUsername(String username) {
        return repository.findByUsername(username);
    }

# Summary: 

@Override
    public Optional<User> getByUsernameForAuth(String username) {
        Optional<User> user = repository.findByUsername(username);
        if (user.isPresent()) {
            UserCredential credentials = userCredentialRepository.findByUserId(user.get().getId());
            user.get().setCredentials(credentials);
            return user;
        }
        return Optional.empty();
    }

# Summary: 

@Override
    public User persist(User user) {
        User userRes = repository.save(user);
        UserCredential credentials = user.getCredentials();
        credentials.setUserId(userRes.getId());
        userCredentialRepository.save(credentials);
        return userRes;
    }

# Summary: 

@Override
    public List<User> getByUserIdList(List<UUID> studentIds) {
        return repository.findAllById(studentIds);
    }

# Summary: 

@Override
    public List<BasicUserDto> basicSearch(String keyword) {
        return List.of();
    }

# Summary: 

@Override
    public Optional<User> getByEmail(String email) {
        return repository.findByEmail(email);
    }

# Summary: 

@Bean
    public UserDetailsService userDetailsService() {
        return new AppUserDetailsService(userRepository);
    }

# Summary: 

public String extractUsername(String token) {
        Claims claims = extractAllClaims(token);
        return claims.getSubject();
    }

# Summary: 

@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.getByUsernameForAuth(username).orElseThrow(() -> new BusinessException(ErrorConstant.UNAUTHORIZED));

        return UserPrincipal.from(user);
    }

'SimpleGrantedAuthority':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

'GrantedAuthority':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

'Collection':
# Summary: 
public abstract String getProviderName();

public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

'HttpHeaders':
@Service
@Slf4j
public class BaseService {
    @Autowired
    protected Environment env;
    @Value("${spring.application.name}")
    protected String appName;
    @Autowired
    protected ObjectMapper objectMapper;
    @Autowired
    protected HttpServletRequest httpServletRequest;
    @Autowired
    protected HttpServletResponse httpServletResponse;
    public String getMessage(String key) {
        try {
            String result = env.getProperty(key);
            return ObjectUtils.isEmpty(result) ? key : result;
        } catch (Exception e) {
            return key;
    public String getMessage(int code) {
        return getMessage(String.valueOf(code));
    public String getMessage(BusinessError error) {
        return ObjectUtils.isEmpty(error.getMessage()) ? getMessage(error.getCode()) : error.getMessage();
    public Object getRequestValue(String key) {
        return getRequestValue(key, Object.class);
    public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));
    public String getRequestStringValue(String key) {
        return getRequestValue(key, String.class);
    public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();
    public Object getRequestBody() {
        return getRequestValue(RequestKeyConstant.REQUEST_BODY);
    public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);
    public <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        return BaseResponse.ofGetListSucceeded(data, requestList);
    public <T> BaseResponse<T> ofFailed(BusinessException exception, T data) {
        return BaseResponse.ofFailed(getRequestId(), exception, data);
    public <T> BaseResponse<T> ofFailed(BusinessError error, String message, T data) {
        return BaseResponse.ofFailed(getRequestId(), error, message, data);
    public <T> BaseResponse<T> ofFailed(BusinessError error, String message, List<ErrorViolation> errors, T data) {
        return BaseResponse.ofFailed(getRequestId(), error, message, errors, data);
    public BaseResponse ofFailed(BusinessException exception) {
        return BaseResponse.ofFailed(getRequestId(), exception);
    public BaseResponse ofFailed(BusinessError error, String message) {
        return BaseResponse.ofFailed(getRequestId(), error, message);
    public BaseResponse ofFailed(BusinessError error) {
        return BaseResponse.ofFailed(getRequestId(), error, getMessage(error));
    public BaseResponse ofFailed(BusinessError error, String message, List<ErrorViolation> errors) {
        return BaseResponse.ofFailed(getRequestId(), error, message, errors);
    public BaseResponse ofFailed(int errorCode) {
        return BaseResponse.ofFailed(getRequestId(), getBusinessError(errorCode));
    public <T> BaseResponse<T> ofFailed(int errorCode, T data) {
        return BaseResponse.ofFailed(getRequestId(), getBusinessError(errorCode), data);
    public BusinessError getBusinessError(int errorCode) {
        return BusinessError.builder()
                .code(errorCode)
                .message(getMessage(errorCode))
                .build();
    public int getErrorCode(String errorCode, int errorCodeDefault) {
        try {
            return Integer.parseInt(errorCode);
        } catch (NumberFormatException e) {
            return errorCodeDefault;

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

'Enumeration':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

'HttpStatus':
# Summary: 

@ExceptionHandler(HttpStatusCodeException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleHttpStatusCodeException(HttpStatusCodeException exception) {
        HttpStatus statusCode = (HttpStatus) exception.getStatusCode();

        if (statusCode.value() == HttpStatus.BAD_REQUEST.value()) {
            BusinessError error = getBusinessError(ErrorConstant.INVALID_PARAMETERS);
            BaseResponse<?> data = ofFailed(error, getMessage(error), exception.getMessage());
            return new ResponseEntity<>(data, HttpStatus.OK);
        }

        if (statusCode.value() == HttpStatus.UNAUTHORIZED.value()) {
            BusinessError error = getBusinessError(ErrorConstant.UNAUTHORIZED);
            BaseResponse<?> data = ofFailed(error, getMessage(error), exception.getMessage());
            return new ResponseEntity<>(data, HttpStatus.OK);
        }

        if (statusCode.value() == HttpStatus.FORBIDDEN.value()) {
            BusinessError error = getBusinessError(ErrorConstant.FORBIDDEN_ERROR);
            BaseResponse<?> data = ofFailed(error, getMessage(error), exception.getMessage());
            return new ResponseEntity<>(data, HttpStatus.OK);
        }

        if (statusCode.value() == HttpStatus.NOT_FOUND.value()) {
            BusinessError error = getBusinessError(ErrorConstant.NOT_FOUND);
            BaseResponse<?> data = ofFailed(error, getMessage(error), exception.getMessage());
            return new ResponseEntity<>(data, HttpStatus.OK);
        }

        if (statusCode.value() == HttpStatus.INTERNAL_SERVER_ERROR.value()) {
            BusinessError error = getBusinessError(ErrorConstant.INTERNAL_SERVER_ERROR);
            BaseResponse<?> data = ofFailed(error, getMessage(error), exception.getMessage());
            return new ResponseEntity<>(data, HttpStatus.OK);
        }

        throw exception;
    }

No new code found for symbol: Meta.

No new code found for symbol: ErrorConstant.UNAUTHORIZED.

'ErrorConstant.INVALID_PARAMETERS':
public BaseResponse ofFailed(BusinessError error, String message, List<ErrorViolation> errors) {
        return BaseResponse.ofFailed(getRequestId(), error, message, errors);

'ErrorConstant.FORBIDDEN_ERROR':
@GetMapping("/me")
    public BaseResponse<AuthProfileResponse> whoAmI(@CurrentUser UserPrincipal requester) {
        return baseService.ofSucceeded(authService.getAuthProfile(requester.getId().toString()));

No new code found for symbol: ErrorConstant.NOT_FOUND.

No new code found for symbol: ErrorConstant.INTERNAL_SERVER_ERROR.

No new code found for symbol: PronunciationLevel.

No new code found for symbol: ErrorViolation.

No new code found for symbol: OptionDto.

No new code found for symbol: QuizNavigationMode.

No new code found for symbol: Difficulty.

            REQUIREMENTS TO ANALYZE:
            Sprint Planning for Pronunciation Accuracy: A Business Perspective
Our team is embarking on a new sprint, focusing on enhancing our language learning platform. A key initiative for this sprint is to deliver a robust Pronunciation Accuracy Feature. The goal is to provide our users with immediate and detailed feedback on their spoken language, helping them improve their pronunciation and build confidence.

Product Vision for Pronunciation Accuracy
"To empower our users with precise, instant feedback on their pronunciation, fostering a more effective and engaging language learning experience."

User Stories & Acceptance Criteria
User Story: As a Language Learner, I want to submit my spoken audio and text so that I can receive a detailed assessment of my pronunciation accuracy.
Description: Our users need a way to practice speaking and immediately understand how well they pronounced specific words or phrases. This direct feedback is crucial for self-correction and progress tracking.

Acceptance Criteria:

Given I have an audio recording of my speech and the corresponding text I intended to say,

When I submit this audio and text to the system,

Then the system should process my submission to determine pronunciation accuracy.

And the system must provide a comprehensive accuracy report including:

When my pronunciation started and ended within the audio.

The phonetic representation (IPA script) of what I said.

An indication of whether all individual sounds were correctly pronounced.

The words and their phonetic forms that the system matched to my speech.

A categorization of my overall pronunciation accuracy (e.g., "Excellent," "Good," "Needs Improvement").

A numerical score representing my pronunciation accuracy.

The exact original text and its phonetic representation that I was supposed to say.

And if for any reason the pronunciation analysis cannot be completed (e.g., the external service we rely on is unavailable), I should receive a clear message indicating that the accuracy assessment failed.

            TEST CASES TO VERIFY:
            Positive Test Cases:
TC-PA-001: Verify that the API correctly processes a high-quality audio submission with perfectly pronounced text.

TC-PA-002: Verify that the API correctly processes audio with minor deviations or a noticeable accent, providing a non-perfect but reasonable score.

Negative & Edge Test Cases:
TC-PA-003: Verify that the API gracefully handles the scenario where the external pronunciation service is down or unresponsive.

TC-PA-004: Verify that the API handles an invalid or corrupted Base64 audio string.

TC-PA-005: Verify that the API handles an empty Base64 audio string.

TC-PA-006: Verify that the API handles an empty text field.

TC-PA-007: Verify that the API processes audio and text that do not match, returning a low accuracy score.

Data Integrity & Constraints Test Cases:
TC-PA-008: Test the API's behavior with an audio file that approaches or exceeds expected size limits.

TC-PA-009: Test the API's behavior with a very long text input.

            ADDITIONAL INSTRUCTIONS:
            PronunciationAccuracyResponseDto

            If you don't have enough context, call the get_project_code_context tool to get more context, don't assume.
            If you have enough context, provide your final analysis as valid JSON with this structure:
            {
                "document": "detailed explanation of what the endpoint does",
                "requirement_coverage": [
                    {
                        "requirement": "exact requirement text",
                        "coverage_score": "0-100",
                        "explain": "how the code meets or fails this requirement"
                    }
                ],
                "test_cases": [
                    {
                        "test_case": "exact test case text",
                        "coverage_score": "0-100", 
                        "explain": "whether this test case is covered by the implementation"
                    }
                ],
                "improvements": [
                    {
                        "type": "category",
                        "reason": "what needs improvement",
                        "solution": "recommended fix"
                    }
                ]
            }

            Do not assume any code logic, always check the code and use get_project_code_context if any part of the code is not fully implemented.
            Your response: