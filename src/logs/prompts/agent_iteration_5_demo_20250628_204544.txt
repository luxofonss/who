Project: demo
Timestamp: 2025-06-28T20:45:44.760735
Type: agent_iteration_5
================================================================================

You are an expert software architect analyzing the REST endpoint: /api/v1/pub/pronunciations/accuracy
            Your first job is to apply the strategy above
             ANALYSIS STRATEGY:
            1. Review the current context for the endpoint implementation
            2. Get all classes, services, repositories, DTOs, methods and check if they are fully implemented
            3. If you see references to any classes, services, DTOs, or methods that are not fully shown, request more context using the tool
            4. When there are no classes, services, DTOs, or methods that are not fully shown, you have sufficient implementation details, provide your final analysis as JSON. 
            5. Do not assume that you have enough context, always check the code and use get_project_code_context if any part of the code is not fully implemented.

            WHEN TO USE get_project_code_context TOOL:
            - When you see class/interface names without their implementation
            - When service methods are referenced but not shown
            - When DTO/model classes are mentioned but structure is unclear
            - When exception handling classes are referenced
            - When you need to understand dependencies or business logic

            To use the tool, respond with: "I need to get context for [exact_class_or_method_name]"
            Examples:
            - "I need to get context for UserService"
            - "I need to get context for ValidationException"
            - "I need to get context for OrderDto"

            CURRENT CONTEXT:
            # Summary: 
@PostMapping("/accuracy")
    public BaseResponse<Object> getAccuracy(@RequestBody PronunciationAccuracyRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getAccuracy(request));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

Context for 'PronunciationAccuracyRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PronunciationAccuracyRequestDto {
    private String base64Audio;
    private String text;
}

@PostMapping("/accuracy")
    public BaseResponse<Object> getAccuracy(@RequestBody PronunciationAccuracyRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getAccuracy(request));

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@RestController
@RequestMapping("/api/v1/pub/pronunciations")
public class PronunciationController {
    private final BaseService baseService;
    private final PronunciationService pronunciationService;
    public PronunciationController(BaseService baseService, PronunciationService pronunciationService) {
        this.baseService = baseService;
        this.pronunciationService = pronunciationService;
    @GetMapping("/samples")
    public BaseResponse<Object> getSamplePronunciations(GetSampleRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getSample(request));

Context for 'pronunciationService':
# Summary: 

@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);

        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }

        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

# Summary: 

@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);

        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }

        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

Context for 'BaseResponse':
# Summary: 

public static void verifyMetaResponse(BaseResponse<?> baseResponse, HttpStatus httpStatus, int status) {
        if (Objects.isNull(baseResponse) || Objects.isNull(baseResponse.meta)) {
            return;
        }

        Meta meta = baseResponse.meta;
        if (status != meta.getCode()) {
            throw new BusinessException(meta.getCode(), meta.getMessage(), httpStatus);
        }
    }

# Summary: 

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;
    }

# Summary: 

public static <T> BaseResponse<T> ofFailed(String requestId, BusinessException exception, T data) {
        BaseResponse<T> response = ofFailed(exception, data);
        response.meta.setRequestId(requestId);
        response.data = data;
        return response;
    }

# Summary: 

public static <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        BaseResponse<T> response = ofSucceeded(data);
        response.meta.setRequestId(requestList.getRequestId());
        response.meta.setPageSize(requestList.getPageSize());
        response.meta.setPageIndex(requestList.getPageIndex());
        response.meta.setTotalItems(requestList.getTotalItems());
        response.data = data;
        return response;
    }

Context for 'BaseService':
# Summary: 

public String getMessage(BusinessError error) {
        return ObjectUtils.isEmpty(error.getMessage()) ? getMessage(error.getCode()) : error.getMessage();
    }

# Summary: 

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));
    }

# Summary: 

public String getRequestStringValue(String key) {
        return getRequestValue(key, String.class);
    }

# Summary: 

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();
    }

# Summary: 

public Object getRequestBody() {
        return getRequestValue(RequestKeyConstant.REQUEST_BODY);
    }

# Summary: 

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);
    }

# Summary: 

public <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        return BaseResponse.ofGetListSucceeded(data, requestList);
    }

# Summary: 

public <T> BaseResponse<T> ofFailed(int errorCode, T data) {
        return BaseResponse.ofFailed(getRequestId(), getBusinessError(errorCode), data);
    }

# Summary: 

public BusinessError getBusinessError(int errorCode) {
        return BusinessError.builder()
                .code(errorCode)
                .message(getMessage(errorCode))
                .build();
    }

# Summary: 

public HttpHeaders getHeaders() {
        HttpHeaders headers = new HttpHeaders();
        Enumeration<String> headerNames = httpServletRequest.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = httpServletRequest.getHeader(headerName);
            headers.add(headerName, headerValue);
        }
        return headers;
    }

# Summary: 

public int getErrorCode(String errorCode, int errorCodeDefault) {
        try {
            return Integer.parseInt(errorCode);
        } catch (NumberFormatException e) {
            return errorCodeDefault;
        }
    }

Context for 'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

Context for 'httpServletRequest':
# Summary: 
@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    }
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    }
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
                    }
                }
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            }
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
            }
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
                }
            }
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));
        }
    }
}

public abstract String uploadFile(MultipartFile file);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'PronunciationAccuracyRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PronunciationAccuracyRequestDto {
    private String base64Audio;
    private String text;
}

@PostMapping("/accuracy")
    public BaseResponse<Object> getAccuracy(@RequestBody PronunciationAccuracyRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getAccuracy(request));

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@RestController
@RequestMapping("/api/v1/pub/pronunciations")
public class PronunciationController {
    private final BaseService baseService;
    private final PronunciationService pronunciationService;
    public PronunciationController(BaseService baseService, PronunciationService pronunciationService) {
        this.baseService = baseService;
        this.pronunciationService = pronunciationService;
    @GetMapping("/samples")
    public BaseResponse<Object> getSamplePronunciations(GetSampleRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getSample(request));

Context for 'pronunciationService':
# Summary: 

@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);

        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }

        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

# Summary: 

@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);

        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }

        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

Context for 'BaseResponse':
# Summary: 

public static void verifyMetaResponse(BaseResponse<?> baseResponse, HttpStatus httpStatus, int status) {
        if (Objects.isNull(baseResponse) || Objects.isNull(baseResponse.meta)) {
            return;
        }

        Meta meta = baseResponse.meta;
        if (status != meta.getCode()) {
            throw new BusinessException(meta.getCode(), meta.getMessage(), httpStatus);
        }
    }

# Summary: 

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;
    }

# Summary: 

public static <T> BaseResponse<T> ofFailed(String requestId, BusinessException exception, T data) {
        BaseResponse<T> response = ofFailed(exception, data);
        response.meta.setRequestId(requestId);
        response.data = data;
        return response;
    }

# Summary: 

public static <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        BaseResponse<T> response = ofSucceeded(data);
        response.meta.setRequestId(requestList.getRequestId());
        response.meta.setPageSize(requestList.getPageSize());
        response.meta.setPageIndex(requestList.getPageIndex());
        response.meta.setTotalItems(requestList.getTotalItems());
        response.data = data;
        return response;
    }

Context for 'BaseService':
# Summary: 

public String getMessage(BusinessError error) {
        return ObjectUtils.isEmpty(error.getMessage()) ? getMessage(error.getCode()) : error.getMessage();
    }

# Summary: 

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));
    }

# Summary: 

public String getRequestStringValue(String key) {
        return getRequestValue(key, String.class);
    }

# Summary: 

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();
    }

# Summary: 

public Object getRequestBody() {
        return getRequestValue(RequestKeyConstant.REQUEST_BODY);
    }

# Summary: 

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);
    }

# Summary: 

public <T> BaseResponse<T> ofGetListSucceeded(T data, BasicRequestList requestList) {
        return BaseResponse.ofGetListSucceeded(data, requestList);
    }

# Summary: 

public <T> BaseResponse<T> ofFailed(int errorCode, T data) {
        return BaseResponse.ofFailed(getRequestId(), getBusinessError(errorCode), data);
    }

# Summary: 

public BusinessError getBusinessError(int errorCode) {
        return BusinessError.builder()
                .code(errorCode)
                .message(getMessage(errorCode))
                .build();
    }

# Summary: 

public HttpHeaders getHeaders() {
        HttpHeaders headers = new HttpHeaders();
        Enumeration<String> headerNames = httpServletRequest.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = httpServletRequest.getHeader(headerName);
            headers.add(headerName, headerValue);
        }
        return headers;
    }

# Summary: 

public int getErrorCode(String errorCode, int errorCodeDefault) {
        try {
            return Integer.parseInt(errorCode);
        } catch (NumberFormatException e) {
            return errorCodeDefault;
        }
    }

Context for 'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

Context for 'httpServletRequest':
# Summary: 
@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    }
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    }
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
                    }
                }
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            }
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
            }
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
                }
            }
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));
        }
    }
}

public abstract String uploadFile(MultipartFile file);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'PronunciationAccuracyResponseDto':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PronunciationAccuracyResponseDto {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyRequest':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
public class PronunciationAccuracyRequest {
    private String base64Audio;
    private String language;
    @JsonProperty("title")
    private String text;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyResponse':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@Data
public class PronunciationAccuracyResponse {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'pronunciationMapper':
# Summary: 
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

Context for 'pronunciationFeignClient':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract byte[] downloadFile(String fileName);

Context for 'GetSampleRequest':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
public class GetSampleRequest {
    private String category;
    private String language;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String transcript;

public abstract String getFileUrl(String fileName);

Context for 'GetSampleResponse':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleResponse {
    @JsonProperty("ipa_transcript")
    private String ipaTranscript;
    @JsonProperty("real_transcript")
    private String realTranscript;
    @JsonProperty("transcript_translation")
    private String transcriptTranslation;

public abstract String getFileUrl(String fileName);

Context for 'GetPronunciationSampleResponseDto':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetPronunciationSampleResponseDto {
    private String ipaTranscript;
    private String realTranscript;
    private String transcriptTranslation;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);

Context for 'GetSampleRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleRequestDto {
    @NotNull
    private PronunciationLevel level;
    private String customText;
}

public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'BusinessException':
# Summary: 

@ExceptionHandler(BusinessException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleBusinessException(BusinessException exception) {
        exception.getError().setMessage(getMessage(exception.getError()));
        Object dataException = exception.getError().getData();
        BaseResponse<?> data = ofFailed(exception);
        if(!ObjectUtils.isEmpty(dataException) && dataException instanceof String) {
            data.getMeta().setErrors(Collections.singletonList(
                ErrorViolation.builder().description((String) dataException).build()));
        }
        return new ResponseEntity<>(data, exception.getError().getHttpStatus() == null
                ? HttpStatus.OK : exception.getError().getHttpStatus());
    }

Context for 'ErrorConstant':
# Summary: 
public class ErrorConstant {
    private ErrorConstant() {}
    /**
     * Write the error code prefixed with 200 below
     * 200
     */
    public static final int SUCCESS = 200000;
    public static final int SUCCESS_200 = 200;
    /**
     * Write the error code prefixed with 400 below
     * 400
     */
    public static final int INVALID_PARAMETERS = 4000001;
    public static final int SYSTEM_CONFIGURATION_NOT_FOUND = 4004208;
    public static final int TRANSACTION_NOT_FOUND = 4001210;
    public static final int TRANSACTION_NOT_EXIST = 4001218;
    public static final int TRANSACTION_MUST_NOT_REFUND = 4001212;
    public static final int TRANSACTION_NOT_SUCCESS = 4001213;
    public static final int TRANSACTION_NOT_ENOUGH_AMOUNT = 4001214;
    public static final int HTTP_CONNECTION_ERROR  = 4009000;
    public static final int NULL_META_DATA_RESPONSE  = 4009001;
    /**
     * Write the error code prefixed with 401 below
     * 401
     */
    public static final int UNAUTHORIZED = 4010001;
    public static final int USERNAME_PASSWORD_WRONG = 4010002;
    /**
     * Write the error code prefixed with 403 below
     * 403
     */
    public static final int FORBIDDEN_ERROR = 4030001;
    /**
     *  Write the error code prefixed with 404 below
     * 404
     */
    public static final int NOT_FOUND = 4040001;
    public static final int QUIZ_NOT_FOUND = 4040002;
    public static final int QUIZ_ATTEMPT_NOT_FOUND = 4040003;
    public static final int QUIZ_ATTEMPT_SUBMITTED = 4040004;
    public static final int QUESTION_DOES_NOT_BELONG_TO_QUIZ = 4040005;
    public static final int QUESTION_NOT_FOUND = 4040006;
    public static final int QUIZ_ATTEMPT_NOT_BELONG_TO_USER = 4040007;
    public static final int QUIZ_TIME_LIMIT_EXCEEDED = 4040008;
    public static final int QUIZ_NOT_SAVED = 4040009;
    public static final int GET_PRONUNCIATION_SAMPLE_ERROR = 4040010;
    public static final int GET_PRONUNCIATION_ACCURACY_ERROR = 4040011;
    /** @Get_VA_number_information*/
    public static final int INVALID_VA_NUMBER = 40010525;
    /**
     * Write the error code prefixed with 500 below
     * 500
     */
    public static final int INTERNAL_SERVER_ERROR = 5001001;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String deleteFile(String fileName);

Context for 'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

Context for 'BaseResponse.ofSucceeded()':
# Summary: 
@GetMapping("/me")
    public BaseResponse<AuthProfileResponse> whoAmI(@CurrentUser UserPrincipal requester) {
        return baseService.ofSucceeded(authService.getAuthProfile(requester.getId().toString()));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@GetMapping("/attempts")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getQuizAttempts(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizAttempts(currentUser.getId().toString()));

@GetMapping("/my")
    BaseResponse<List<Quiz>> getMyQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizzes(currentUser.getId()));

Context for 'PronunciationAccuracyResponseDto':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PronunciationAccuracyResponseDto {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyRequest':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
public class PronunciationAccuracyRequest {
    private String base64Audio;
    private String language;
    @JsonProperty("title")
    private String text;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyResponse':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@Data
public class PronunciationAccuracyResponse {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'pronunciationMapper':
# Summary: 
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

Context for 'pronunciationFeignClient':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract byte[] downloadFile(String fileName);

Context for 'GetPronunciationSampleResponseDto':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetPronunciationSampleResponseDto {
    private String ipaTranscript;
    private String realTranscript;
    private String transcriptTranslation;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);

Context for 'GetSampleRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleRequestDto {
    @NotNull
    private PronunciationLevel level;
    private String customText;
}

public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'GetSampleRequest':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
public class GetSampleRequest {
    private String category;
    private String language;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String transcript;

public abstract String getFileUrl(String fileName);

Context for 'GetSampleResponse':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleResponse {
    @JsonProperty("ipa_transcript")
    private String ipaTranscript;
    @JsonProperty("real_transcript")
    private String realTranscript;
    @JsonProperty("transcript_translation")
    private String transcriptTranslation;

public abstract String getFileUrl(String fileName);

Context for 'BusinessException':
# Summary: 

@ExceptionHandler(BusinessException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleBusinessException(BusinessException exception) {
        exception.getError().setMessage(getMessage(exception.getError()));
        Object dataException = exception.getError().getData();
        BaseResponse<?> data = ofFailed(exception);
        if(!ObjectUtils.isEmpty(dataException) && dataException instanceof String) {
            data.getMeta().setErrors(Collections.singletonList(
                ErrorViolation.builder().description((String) dataException).build()));
        }
        return new ResponseEntity<>(data, exception.getError().getHttpStatus() == null
                ? HttpStatus.OK : exception.getError().getHttpStatus());
    }

Context for 'ErrorConstant':
# Summary: 
public class ErrorConstant {
    private ErrorConstant() {}
    /**
     * Write the error code prefixed with 200 below
     * 200
     */
    public static final int SUCCESS = 200000;
    public static final int SUCCESS_200 = 200;
    /**
     * Write the error code prefixed with 400 below
     * 400
     */
    public static final int INVALID_PARAMETERS = 4000001;
    public static final int SYSTEM_CONFIGURATION_NOT_FOUND = 4004208;
    public static final int TRANSACTION_NOT_FOUND = 4001210;
    public static final int TRANSACTION_NOT_EXIST = 4001218;
    public static final int TRANSACTION_MUST_NOT_REFUND = 4001212;
    public static final int TRANSACTION_NOT_SUCCESS = 4001213;
    public static final int TRANSACTION_NOT_ENOUGH_AMOUNT = 4001214;
    public static final int HTTP_CONNECTION_ERROR  = 4009000;
    public static final int NULL_META_DATA_RESPONSE  = 4009001;
    /**
     * Write the error code prefixed with 401 below
     * 401
     */
    public static final int UNAUTHORIZED = 4010001;
    public static final int USERNAME_PASSWORD_WRONG = 4010002;
    /**
     * Write the error code prefixed with 403 below
     * 403
     */
    public static final int FORBIDDEN_ERROR = 4030001;
    /**
     *  Write the error code prefixed with 404 below
     * 404
     */
    public static final int NOT_FOUND = 4040001;
    public static final int QUIZ_NOT_FOUND = 4040002;
    public static final int QUIZ_ATTEMPT_NOT_FOUND = 4040003;
    public static final int QUIZ_ATTEMPT_SUBMITTED = 4040004;
    public static final int QUESTION_DOES_NOT_BELONG_TO_QUIZ = 4040005;
    public static final int QUESTION_NOT_FOUND = 4040006;
    public static final int QUIZ_ATTEMPT_NOT_BELONG_TO_USER = 4040007;
    public static final int QUIZ_TIME_LIMIT_EXCEEDED = 4040008;
    public static final int QUIZ_NOT_SAVED = 4040009;
    public static final int GET_PRONUNCIATION_SAMPLE_ERROR = 4040010;
    public static final int GET_PRONUNCIATION_ACCURACY_ERROR = 4040011;
    /** @Get_VA_number_information*/
    public static final int INVALID_VA_NUMBER = 40010525;
    /**
     * Write the error code prefixed with 500 below
     * 500
     */
    public static final int INTERNAL_SERVER_ERROR = 5001001;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String deleteFile(String fileName);

Context for 'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

Context for 'BaseResponse.ofSucceeded()':
# Summary: 
@GetMapping("/me")
    public BaseResponse<AuthProfileResponse> whoAmI(@CurrentUser UserPrincipal requester) {
        return baseService.ofSucceeded(authService.getAuthProfile(requester.getId().toString()));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@GetMapping("/attempts")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getQuizAttempts(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizAttempts(currentUser.getId().toString()));

@GetMapping("/my")
    BaseResponse<List<Quiz>> getMyQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizzes(currentUser.getId()));

Context for 'httpServletRequest':
# Summary: 
@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    }
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    }
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
                    }
                }
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            }
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
            }
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
                }
            }
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));
        }
    }
}

public abstract String uploadFile(MultipartFile file);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'PronunciationService.getAccuracy(request)':
# Summary: 
@PostMapping("/accuracy")
    public BaseResponse<Object> getAccuracy(@RequestBody PronunciationAccuracyRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getAccuracy(request));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@GetMapping("/samples")
    public BaseResponse<Object> getSamplePronunciations(GetSampleRequestDto request) {
        return baseService.ofSucceeded(pronunciationService.getSample(request));

@Aspect
@Component
@Order(value = 1)
@Slf4j
public class LogsActivityAOPHandler extends BaseService {
    private final HttpServletRequest httpServletRequest;
    public static final String service_name = "service_name";
    public static final String request_path = "request_path";
    public static final String query_string = "query_string";
    public static final String code_file = "code_file";
    public static final String method_name = "method_name";
    public static final String message_type = "message_type";
    public static final String request_id = "request_id";
    public static final String request = "request";
    public static final String response = "response";
    public static final String execution_time = "execution_time";
    public static final String status_code = "status_code";
    public static final String error_code = "error_code";
    public static final String headers = "headers";
    public LogsActivityAOPHandler(HttpServletRequest httpServletRequest) {
        this.httpServletRequest = httpServletRequest;
    @Around("execution(* *(..)) && @annotation(logsActivityAnnotation)")
    @SneakyThrows
    public Object logsActivityAnnotation(ProceedingJoinPoint point, LogsActivityAnnotation logsActivityAnnotation) {
        // Parameter
        Object objectRequest = point.getArgs().length > 0 ? point.getArgs()[0] : httpServletRequest.getParameterMap();
        String requestId = getRequestId();
        // Log request
        Map<String, Object> mapCustomizeLog = new HashMap<>();
        mapCustomizeLog.put(LogsActivityAOPHandler.request_path, httpServletRequest.getRequestURI());
        mapCustomizeLog.put(LogsActivityAOPHandler.query_string, httpServletRequest.getQueryString());
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.request);
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectRequest, mapCustomizeLog);
        // Process and get response
        long timeStart = new Date().getTime();
        Object objectResponse = point.proceed();
        // Log response
        long timeHandle = new Date().getTime() - timeStart;
        mapCustomizeLog.put(LogsActivityAOPHandler.execution_time, timeHandle);
        mapCustomizeLog.put(LogsActivityAOPHandler.code_file, point.getSignature().getDeclaringTypeName());
        mapCustomizeLog.put(LogsActivityAOPHandler.method_name, point.getSignature().getName());
        mapCustomizeLog.put(LogsActivityAOPHandler.request_id, requestId);
        mapCustomizeLog.put(LogsActivityAOPHandler.message_type, LogsActivityAOPHandler.response);
        mapCustomizeLog.put(LogsActivityAOPHandler.headers, Utils.redact(JsonUtils.convertObjectToString(getHeaders())));
        displayLog(objectResponse, mapCustomizeLog);
        return objectResponse;
    private void displayLog(Object messageObject, Map<String, Object> mapCustomizeLog) throws JsonProcessingException {
        if (messageObject instanceof Exception) {
            Exception e = (Exception) messageObject;
            if (e instanceof MethodArgumentNotValidException) {
                log.info(Utils.redact(objectMapper.writeValueAsString(getRequestBody())), entries(mapCustomizeLog));
                return;
            } else if (e instanceof BusinessException) {
                BusinessException businessException = (BusinessException) e;
                if (!ObjectUtils.isEmpty(businessException.getError())) {
                    if (!ObjectUtils.isEmpty(businessException.getError().getMessage())) {
                        log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
                        return;
                    } else if (!ObjectUtils.isEmpty(businessException.getError().getData())) {
                        log.info(Utils.redact(objectMapper.writeValueAsString(businessException.getError().getData())),
                                entries(mapCustomizeLog));
                        return;
            } else if (!ObjectUtils.isEmpty(e.getMessage())) {
                log.info(Utils.redact(e.getMessage()), entries(mapCustomizeLog));
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.request)) {
                log.error("Request_id: {}, Exception: ", getRequestId(), e);
        } else {
            if (mapCustomizeLog.get(LogsActivityAOPHandler.message_type).toString().equals(LogsActivityAOPHandler.response)) {
                if (messageObject instanceof ResponseEntity) {
                    ResponseEntity responseEntity = (ResponseEntity) messageObject;
                    BaseResponse baseResponse = JsonUtils.getGenericObject(responseEntity.getBody(), BaseResponse.class);
                    log.info(Utils.redact(objectMapper.writeValueAsString(baseResponse)), entries(mapCustomizeLog));
                    return;
            log.info(Utils.redact(objectMapper.writeValueAsString(messageObject)), entries(mapCustomizeLog));

Context for 'PronunciationAccuracyResponseDto':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PronunciationAccuracyResponseDto {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyRequest':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
public class PronunciationAccuracyRequest {
    private String base64Audio;
    private String language;
    @JsonProperty("title")
    private String text;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyResponse':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@Data
public class PronunciationAccuracyResponse {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'pronunciationFeignClient':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract byte[] downloadFile(String fileName);

Context for 'pronunciationMapper':
# Summary: 
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

Context for 'GetPronunciationSampleResponseDto':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetPronunciationSampleResponseDto {
    private String ipaTranscript;
    private String realTranscript;
    private String transcriptTranslation;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);

Context for 'GetSampleRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleRequestDto {
    @NotNull
    private PronunciationLevel level;
    private String customText;
}

public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'GetSampleRequest':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
public class GetSampleRequest {
    private String category;
    private String language;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String transcript;

public abstract String getFileUrl(String fileName);

Context for 'GetSampleResponse':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleResponse {
    @JsonProperty("ipa_transcript")
    private String ipaTranscript;
    @JsonProperty("real_transcript")
    private String realTranscript;
    @JsonProperty("transcript_translation")
    private String transcriptTranslation;

public abstract String getFileUrl(String fileName);

Context for 'BusinessException':
# Summary: 

@ExceptionHandler(BusinessException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleBusinessException(BusinessException exception) {
        exception.getError().setMessage(getMessage(exception.getError()));
        Object dataException = exception.getError().getData();
        BaseResponse<?> data = ofFailed(exception);
        if(!ObjectUtils.isEmpty(dataException) && dataException instanceof String) {
            data.getMeta().setErrors(Collections.singletonList(
                ErrorViolation.builder().description((String) dataException).build()));
        }
        return new ResponseEntity<>(data, exception.getError().getHttpStatus() == null
                ? HttpStatus.OK : exception.getError().getHttpStatus());
    }

Context for 'ErrorConstant':
# Summary: 
public class ErrorConstant {
    private ErrorConstant() {}
    /**
     * Write the error code prefixed with 200 below
     * 200
     */
    public static final int SUCCESS = 200000;
    public static final int SUCCESS_200 = 200;
    /**
     * Write the error code prefixed with 400 below
     * 400
     */
    public static final int INVALID_PARAMETERS = 4000001;
    public static final int SYSTEM_CONFIGURATION_NOT_FOUND = 4004208;
    public static final int TRANSACTION_NOT_FOUND = 4001210;
    public static final int TRANSACTION_NOT_EXIST = 4001218;
    public static final int TRANSACTION_MUST_NOT_REFUND = 4001212;
    public static final int TRANSACTION_NOT_SUCCESS = 4001213;
    public static final int TRANSACTION_NOT_ENOUGH_AMOUNT = 4001214;
    public static final int HTTP_CONNECTION_ERROR  = 4009000;
    public static final int NULL_META_DATA_RESPONSE  = 4009001;
    /**
     * Write the error code prefixed with 401 below
     * 401
     */
    public static final int UNAUTHORIZED = 4010001;
    public static final int USERNAME_PASSWORD_WRONG = 4010002;
    /**
     * Write the error code prefixed with 403 below
     * 403
     */
    public static final int FORBIDDEN_ERROR = 4030001;
    /**
     *  Write the error code prefixed with 404 below
     * 404
     */
    public static final int NOT_FOUND = 4040001;
    public static final int QUIZ_NOT_FOUND = 4040002;
    public static final int QUIZ_ATTEMPT_NOT_FOUND = 4040003;
    public static final int QUIZ_ATTEMPT_SUBMITTED = 4040004;
    public static final int QUESTION_DOES_NOT_BELONG_TO_QUIZ = 4040005;
    public static final int QUESTION_NOT_FOUND = 4040006;
    public static final int QUIZ_ATTEMPT_NOT_BELONG_TO_USER = 4040007;
    public static final int QUIZ_TIME_LIMIT_EXCEEDED = 4040008;
    public static final int QUIZ_NOT_SAVED = 4040009;
    public static final int GET_PRONUNCIATION_SAMPLE_ERROR = 4040010;
    public static final int GET_PRONUNCIATION_ACCURACY_ERROR = 4040011;
    /** @Get_VA_number_information*/
    public static final int INVALID_VA_NUMBER = 40010525;
    /**
     * Write the error code prefixed with 500 below
     * 500
     */
    public static final int INTERNAL_SERVER_ERROR = 5001001;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String deleteFile(String fileName);

Context for 'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

Context for 'PronunciationService.getAccuracy':
# Summary: 
@GetMapping("/attempts")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getQuizAttempts(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizAttempts(currentUser.getId().toString()));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@GetMapping("/my")
    BaseResponse<List<Quiz>> getMyQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizzes(currentUser.getId()));

public abstract String getFileUrl(String fileName);

Context for 'BaseService.ofSucceeded':
# Summary: 

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);
    }

Context for 'PronunciationAccuracyResponseDto':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PronunciationAccuracyResponseDto {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyResponse':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
@Data
public class PronunciationAccuracyResponse {
    private String startTime;
    private String endTime;
    private String ipaScript;
    private String isLetterCorrectAllWords;
    private String matchedTranscripts;
    private String matchedTranscriptsIpa;
    private String pairAccuracyCategory;
    private Integer pronunciationAccuracy;
    private String realTranscript;
    private String realTranscripts;
    private String realTranscriptsIpa;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'PronunciationAccuracyRequest':
# Summary: 
@Override
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        req.setLanguage("en");
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        }
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);
    }

@Data
public class PronunciationAccuracyRequest {
    private String base64Audio;
    private String language;
    @JsonProperty("title")
    private String text;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);

Context for 'pronunciationMapper':
# Summary: 
public abstract String getProviderName();

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract String getFileUrl(String fileName);

Context for 'pronunciationFeignClient':
# Summary: 
@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);
    }
}

public abstract byte[] downloadFile(String fileName);

Context for 'GetPronunciationSampleResponseDto':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetPronunciationSampleResponseDto {
    private String ipaTranscript;
    private String realTranscript;
    private String transcriptTranslation;

@Service
public class PronunciationServiceImpl implements PronunciationService {
    private final PronunciationFeignClient pronunciationFeignClient;
    private final PronunciationMapper pronunciationMapper;
    public PronunciationServiceImpl(PronunciationFeignClient pronunciationFeignClient, PronunciationMapper pronunciationMapper) {
        this.pronunciationFeignClient = pronunciationFeignClient;
        this.pronunciationMapper = pronunciationMapper;
    public PronunciationAccuracyResponseDto getAccuracy(PronunciationAccuracyRequestDto request) {
        PronunciationAccuracyRequest req = pronunciationMapper.toPronunciationAccuracyRequest(request);
        PronunciationAccuracyResponse response = pronunciationFeignClient.getAccuracyFromRecordedAudio(req);
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_ACCURACY_ERROR);
        return pronunciationMapper.toPronunciationAccuracyResponseDto(response);

Context for 'GetSampleRequestDto':
# Summary: 
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleRequestDto {
    @NotNull
    private PronunciationLevel level;
    private String customText;
}

public abstract String getFileUrl(String fileName);

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

Context for 'GetSampleRequest':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
public class GetSampleRequest {
    private String category;
    private String language;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String transcript;

public abstract String getFileUrl(String fileName);

Context for 'GetSampleResponse':
# Summary: 
@Override
    public GetPronunciationSampleResponseDto getSample(GetSampleRequestDto request) {
        GetSampleRequest req = pronunciationMapper.toSampleRequest(request);
        req.setCategory(request.getLevel().getValue());
        req.setLanguage("en");
        GetSampleResponse response = pronunciationFeignClient.getSample(req);
        if (response == null) {
            throw new BusinessException(ErrorConstant.GET_PRONUNCIATION_SAMPLE_ERROR);
        }
        return pronunciationMapper.toGetPronunciationSampleResponseDto(response);
    }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetSampleResponse {
    @JsonProperty("ipa_transcript")
    private String ipaTranscript;
    @JsonProperty("real_transcript")
    private String realTranscript;
    @JsonProperty("transcript_translation")
    private String transcriptTranslation;

public abstract String getFileUrl(String fileName);

Context for 'BusinessException':
# Summary: 

@ExceptionHandler(BusinessException.class)
    @LogsActivityAnnotation
    public ResponseEntity<BaseResponse<?>> handleBusinessException(BusinessException exception) {
        exception.getError().setMessage(getMessage(exception.getError()));
        Object dataException = exception.getError().getData();
        BaseResponse<?> data = ofFailed(exception);
        if(!ObjectUtils.isEmpty(dataException) && dataException instanceof String) {
            data.getMeta().setErrors(Collections.singletonList(
                ErrorViolation.builder().description((String) dataException).build()));
        }
        return new ResponseEntity<>(data, exception.getError().getHttpStatus() == null
                ? HttpStatus.OK : exception.getError().getHttpStatus());
    }

Context for 'ErrorConstant':
# Summary: 
public class ErrorConstant {
    private ErrorConstant() {}
    /**
     * Write the error code prefixed with 200 below
     * 200
     */
    public static final int SUCCESS = 200000;
    public static final int SUCCESS_200 = 200;
    /**
     * Write the error code prefixed with 400 below
     * 400
     */
    public static final int INVALID_PARAMETERS = 4000001;
    public static final int SYSTEM_CONFIGURATION_NOT_FOUND = 4004208;
    public static final int TRANSACTION_NOT_FOUND = 4001210;
    public static final int TRANSACTION_NOT_EXIST = 4001218;
    public static final int TRANSACTION_MUST_NOT_REFUND = 4001212;
    public static final int TRANSACTION_NOT_SUCCESS = 4001213;
    public static final int TRANSACTION_NOT_ENOUGH_AMOUNT = 4001214;
    public static final int HTTP_CONNECTION_ERROR  = 4009000;
    public static final int NULL_META_DATA_RESPONSE  = 4009001;
    /**
     * Write the error code prefixed with 401 below
     * 401
     */
    public static final int UNAUTHORIZED = 4010001;
    public static final int USERNAME_PASSWORD_WRONG = 4010002;
    /**
     * Write the error code prefixed with 403 below
     * 403
     */
    public static final int FORBIDDEN_ERROR = 4030001;
    /**
     *  Write the error code prefixed with 404 below
     * 404
     */
    public static final int NOT_FOUND = 4040001;
    public static final int QUIZ_NOT_FOUND = 4040002;
    public static final int QUIZ_ATTEMPT_NOT_FOUND = 4040003;
    public static final int QUIZ_ATTEMPT_SUBMITTED = 4040004;
    public static final int QUESTION_DOES_NOT_BELONG_TO_QUIZ = 4040005;
    public static final int QUESTION_NOT_FOUND = 4040006;
    public static final int QUIZ_ATTEMPT_NOT_BELONG_TO_USER = 4040007;
    public static final int QUIZ_TIME_LIMIT_EXCEEDED = 4040008;
    public static final int QUIZ_NOT_SAVED = 4040009;
    public static final int GET_PRONUNCIATION_SAMPLE_ERROR = 4040010;
    public static final int GET_PRONUNCIATION_ACCURACY_ERROR = 4040011;
    /** @Get_VA_number_information*/
    public static final int INVALID_VA_NUMBER = 40010525;
    /**
     * Write the error code prefixed with 500 below
     * 500
     */
    public static final int INTERNAL_SERVER_ERROR = 5001001;
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String deleteFile(String fileName);

Context for 'RequestKeyConstant':
# Summary: 
public class RequestKeyConstant {
    private RequestKeyConstant() {}
    public static final String REQUEST_ID = "request_id";
    public static final String THREAD_REQUEST_ID = "requestId";
    public static final String REQUEST_PARAMETERS = "request_parameters";
    public static final String REQUEST_BODY = "request_body";
    public static final String URI = "uri";
    public static final String X_REQUEST_ID = "X-Request-ID";
    public static final String CONTENT_TYPE = "Content-Type";
    public static final String USER_AGENT = "User-Agent";
    public static final String X_API_KEY = "x-api-key";
    public static final String X_API_SECRET = "x-api-secret";
    public static final String API_KEY = "api_key";
    public static final String API_SECRET = "api_secret";
    public static final String AUTHORIZATION = "Authorization";
}

@SpringBootApplication
@PropertySource(value = "classpath:errors.properties", encoding = "UTF-8")
@ComponentScan("com.edu")
@EnableCaching
@EnableAspectJAutoProxy
@EnableFeignClients(basePackages = "com.edu.onestudy.thirdparty")
public class OneStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneStudyApplication.class, args);

public abstract String getFileUrl(String fileName);

Context for 'PronunciationService.getAccuracy':
# Summary: 
@GetMapping("/attempts")
    @LogsActivityAnnotation
    BaseResponse<List<Quiz>> getQuizAttempts(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizAttempts(currentUser.getId().toString()));
    }

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);

public static <T> BaseResponse<T> ofSucceeded(String requestId) {
        BaseResponse<T> response = ofSucceeded();
        response.meta.setRequestId(requestId);
        return response;

public String getRequestId() {
        return getRequestValue(RequestKeyConstant.REQUEST_ID).toString();

public <T> T getRequestValue(String key, Class<T> clazz) {
        return clazz.cast(httpServletRequest.getAttribute(key));

@GetMapping("/my")
    BaseResponse<List<Quiz>> getMyQuizzes(@CurrentUser UserPrincipal currentUser) {
        return baseService.ofSucceeded(quizService.getMyQuizzes(currentUser.getId()));

public abstract String getFileUrl(String fileName);

Context for 'BaseService.ofSucceeded':
# Summary: 

public <T> BaseResponse<T> ofSucceeded(T data) {
        return BaseResponse.ofSucceeded(getRequestId(), data);
    }

            REQUIREMENTS TO ANALYZE:
            Sprint Planning for Pronunciation Accuracy: A Business Perspective
Our team is embarking on a new sprint, focusing on enhancing our language learning platform. A key initiative for this sprint is to deliver a robust Pronunciation Accuracy Feature. The goal is to provide our users with immediate and detailed feedback on their spoken language, helping them improve their pronunciation and build confidence.

Product Vision for Pronunciation Accuracy
"To empower our users with precise, instant feedback on their pronunciation, fostering a more effective and engaging language learning experience."

User Stories & Acceptance Criteria
User Story: As a Language Learner, I want to submit my spoken audio and text so that I can receive a detailed assessment of my pronunciation accuracy.
Description: Our users need a way to practice speaking and immediately understand how well they pronounced specific words or phrases. This direct feedback is crucial for self-correction and progress tracking.

Acceptance Criteria:

Given I have an audio recording of my speech and the corresponding text I intended to say,

When I submit this audio and text to the system,

Then the system should process my submission to determine pronunciation accuracy.

And the system must provide a comprehensive accuracy report including:

When my pronunciation started and ended within the audio.

The phonetic representation (IPA script) of what I said.

An indication of whether all individual sounds were correctly pronounced.

The words and their phonetic forms that the system matched to my speech.

A categorization of my overall pronunciation accuracy (e.g., "Excellent," "Good," "Needs Improvement").

A numerical score representing my pronunciation accuracy.

The exact original text and its phonetic representation that I was supposed to say.

And if for any reason the pronunciation analysis cannot be completed (e.g., the external service we rely on is unavailable), I should receive a clear message indicating that the accuracy assessment failed.

            TEST CASES TO VERIFY:
            Positive Test Cases:
TC-PA-001: Verify that the API correctly processes a high-quality audio submission with perfectly pronounced text.

TC-PA-002: Verify that the API correctly processes audio with minor deviations or a noticeable accent, providing a non-perfect but reasonable score.

Negative & Edge Test Cases:
TC-PA-003: Verify that the API gracefully handles the scenario where the external pronunciation service is down or unresponsive.

TC-PA-004: Verify that the API handles an invalid or corrupted Base64 audio string.

TC-PA-005: Verify that the API handles an empty Base64 audio string.

TC-PA-006: Verify that the API handles an empty text field.

TC-PA-007: Verify that the API processes audio and text that do not match, returning a low accuracy score.

Data Integrity & Constraints Test Cases:
TC-PA-008: Test the API's behavior with an audio file that approaches or exceeds expected size limits.

TC-PA-009: Test the API's behavior with a very long text input.

            ADDITIONAL INSTRUCTIONS:
            

           
            If you dont have enough context, call the get_project_code_context tool to get more context, don't assume.
            If you have enough context, provide your final analysis as valid JSON with this structure:
            {
                "document": "detailed explanation of what the endpoint does",
                "requirement_coverage": [
                    {
                        "requirement": "exact requirement text",
                        "coverage_score": "0-100",
                        "explain": "how the code meets or fails this requirement"
                    }
                ],
                "test_cases": [
                    {
                        "test_case": "exact test case text",
                        "coverage_score": "0-100", 
                        "explain": "whether this test case is covered by the implementation"
                    }
                ],
                "improvements": [
                    {
                        "type": "category",
                        "reason": "what needs improvement",
                        "solution": "recommended fix"
                    }
                ]
            }

            Do not assume any code logic, always check the code and use get_project_code_context if any part of the code is not fully implemented.
            Your response: